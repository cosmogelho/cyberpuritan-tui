Estrutura de diretórios:
./
├── Cargo.lock
├── Cargo.toml
├── data
│   ├── canon.db
│   ├── piety.db
│   └── saltério
│       ├── converter_para_opus.sh
│       ├── Salmo 100_instrumental.opus
│       ├── Salmo 101_instrumental.opus
│       ├── Salmo 102_instrumental.opus
│       ├── Salmo 103_instrumental.opus
│       ├── Salmo 104_instrumental.opus
│       ├── Salmo 105_instrumental.opus
│       ├── Salmo 106_instrumental.opus
│       ├── Salmo 107_instrumental.opus
│       ├── Salmo 108_instrumental.opus
│       ├── Salmo 109_instrumental.opus
│       ├── Salmo 10_instrumental.opus
│       ├── Salmo 110_a_capela.opus
│       ├── Salmo 110_instrumental.opus
│       ├── Salmo 111_instrumental.opus
│       ├── Salmo 112_instrumental.opus
│       ├── Salmo 113_instrumental.opus
│       ├── Salmo 114_instrumental.opus
│       ├── Salmo 115_instrumental.opus
│       ├── Salmo 116_instrumental.opus
│       ├── Salmo 117_instrumental.opus
│       ├── Salmo 118_instrumental.opus
│       ├── Salmo 119 105-112_instrumental.opus
│       ├── Salmo 119 113-120_instrumental.opus
│       ├── Salmo 119 121-128_instrumental.opus
│       ├── Salmo 119 129-136_instrumental.opus
│       ├── Salmo 119 137-144_instrumental.opus
│       ├── Salmo 119 145-152_instrumental.opus
│       ├── Salmo 119 153-160_instrumental.opus
│       ├── Salmo 119 161-168_instrumental.opus
│       ├── Salmo 119 169-176_instrumental.opus
│       ├── Salmo 119 17-24_instrumental.opus
│       ├── Salmo 119 1-8_instrumental.opus
│       ├── Salmo 119 25-32_instrumental.opus
│       ├── Salmo 119 33-40_instrumental.opus
│       ├── Salmo 119 41-48_instrumental.opus
│       ├── Salmo 119 49-56_instrumental.opus
│       ├── Salmo 119 57-64_instrumental.opus
│       ├── Salmo 119 65-72_instrumental.opus
│       ├── Salmo 119 73-80_instrumental.opus
│       ├── Salmo 119 81-88_instrumental.opus
│       ├── Salmo 119 89-96_instrumental.opus
│       ├── Salmo 119 9-16_instrumental.opus
│       ├── Salmo 119 97-104_instrumental.opus
│       ├── Salmo 11_instrumental.opus
│       ├── Salmo 120_instrumental.opus
│       ├── Salmo 121_instrumental.opus
│       ├── Salmo 122_instrumental.opus
│       ├── Salmo 123_instrumental.opus
│       ├── Salmo 124_instrumental.opus
│       ├── Salmo 125_instrumental.opus
│       ├── Salmo 126_instrumental.opus
│       ├── Salmo 127_instrumental.opus
│       ├── Salmo 128_instrumental.opus
│       ├── Salmo 129_instrumental.opus
│       ├── Salmo 12_a_capela.opus
│       ├── Salmo 12_instrumental.opus
│       ├── Salmo 130_instrumental.opus
│       ├── Salmo 131_instrumental.opus
│       ├── Salmo 132_instrumental.opus
│       ├── Salmo 133_instrumental.opus
│       ├── Salmo 134_instrumental.opus
│       ├── Salmo 135_instrumental.opus
│       ├── Salmo 136_instrumental.opus
│       ├── Salmo 137_instrumental.opus
│       ├── Salmo 138_instrumental.opus
│       ├── Salmo 139_instrumental.opus
│       ├── Salmo 13_instrumental.opus
│       ├── Salmo 140_instrumental.opus
│       ├── Salmo 141_instrumental.opus
│       ├── Salmo 142_instrumental.opus
│       ├── Salmo 143_instrumental.opus
│       ├── Salmo 144_instrumental.opus
│       ├── Salmo 145_instrumental.opus
│       ├── Salmo 146_instrumental.opus
│       ├── Salmo 147_instrumental.opus
│       ├── Salmo 148_instrumental.opus
│       ├── Salmo 149_instrumental.opus
│       ├── Salmo 14_a_capela.opus
│       ├── Salmo 14_instrumental.opus
│       ├── Salmo 150_instrumental.opus
│       ├── Salmo 15_a_capela.opus
│       ├── Salmo 15_instrumental.opus
│       ├── Salmo 16_instrumental.opus
│       ├── Salmo 17_instrumental.opus
│       ├── Salmo 18_instrumental.opus
│       ├── Salmo 19_instrumental.opus
│       ├── Salmo 1_a_capela.opus
│       ├── Salmo 1_instrumental.opus
│       ├── Salmo 20_instrumental.opus
│       ├── Salmo 21_instrumental.opus
│       ├── Salmo 22_instrumental.opus
│       ├── Salmo 23_instrumental.opus
│       ├── Salmo 24_instrumental.opus
│       ├── Salmo 25_instrumental.opus
│       ├── Salmo 26_instrumental.opus
│       ├── Salmo 27_instrumental.opus
│       ├── Salmo 28_instrumental.opus
│       ├── Salmo 29_a_capela.opus
│       ├── Salmo 29_instrumental.opus
│       ├── Salmo 2_a_capela.opus
│       ├── Salmo 2_instrumental.opus
│       ├── Salmo 30_instrumental.opus
│       ├── Salmo 31_instrumental.opus
│       ├── Salmo 32_a_capela.opus
│       ├── Salmo 32_instrumental.opus
│       ├── Salmo 33_instrumental.opus
│       ├── Salmo 34_instrumental.opus
│       ├── Salmo 35_instrumental.opus
│       ├── Salmo 36_instrumental.opus
│       ├── Salmo 37_instrumental.opus
│       ├── Salmo 38_instrumental.opus
│       ├── Salmo 39_instrumental.opus
│       ├── Salmo 3_a_capela.opus
│       ├── Salmo 3_instrumental.opus
│       ├── Salmo 40_instrumental.opus
│       ├── Salmo 41_instrumental.opus
│       ├── Salmo 42_instrumental.opus
│       ├── Salmo 43_instrumental.opus
│       ├── Salmo 44_instrumental.opus
│       ├── Salmo 45_instrumental.opus
│       ├── Salmo 46_instrumental.opus
│       ├── Salmo 47_instrumental.opus
│       ├── Salmo 48_instrumental.opus
│       ├── Salmo 49_instrumental.opus
│       ├── Salmo 4_instrumental.opus
│       ├── Salmo 50_instrumental.opus
│       ├── Salmo 51_instrumental.opus
│       ├── Salmo 52_instrumental.opus
│       ├── Salmo 53_a_capela.opus
│       ├── Salmo 53_instrumental.opus
│       ├── Salmo 54_instrumental.opus
│       ├── Salmo 55_instrumental.opus
│       ├── Salmo 56_instrumental.opus
│       ├── Salmo 57_instrumental.opus
│       ├── Salmo 58_instrumental.opus
│       ├── Salmo 59_instrumental.opus
│       ├── Salmo 5_a_capela.opus
│       ├── Salmo 5_instrumental.opus
│       ├── Salmo 60_instrumental.opus
│       ├── Salmo 61_instrumental.opus
│       ├── Salmo 62_instrumental.opus
│       ├── Salmo 63_instrumental.opus
│       ├── Salmo 64_instrumental.opus
│       ├── Salmo 65_instrumental.opus
│       ├── Salmo 66_instrumental.opus
│       ├── Salmo 67_instrumental.opus
│       ├── Salmo 68_instrumental.opus
│       ├── Salmo 69_instrumental.opus
│       ├── Salmo 6_instrumental.opus
│       ├── Salmo 70_instrumental.opus
│       ├── Salmo 71_instrumental.opus
│       ├── Salmo 72_instrumental.opus
│       ├── Salmo 73_instrumental.opus
│       ├── Salmo 74_instrumental.opus
│       ├── Salmo 75_instrumental.opus
│       ├── Salmo 76_instrumental.opus
│       ├── Salmo 77_instrumental.opus
│       ├── Salmo 78_instrumental.opus
│       ├── Salmo 79_instrumental.opus
│       ├── Salmo 7_instrumental.opus
│       ├── Salmo 80_instrumental.opus
│       ├── Salmo 81_instrumental.opus
│       ├── Salmo 82_instrumental.opus
│       ├── Salmo 83_instrumental.opus
│       ├── Salmo 84_instrumental.opus
│       ├── Salmo 85_instrumental.opus
│       ├── Salmo 86_instrumental.opus
│       ├── Salmo 87_instrumental.opus
│       ├── Salmo 88_instrumental.opus
│       ├── Salmo 89_instrumental.opus
│       ├── Salmo 8_instrumental.opus
│       ├── Salmo 90_instrumental.opus
│       ├── Salmo 91_instrumental.opus
│       ├── Salmo 92_instrumental.opus
│       ├── Salmo 93_instrumental.opus
│       ├── Salmo 94_instrumental.opus
│       ├── Salmo 95_instrumental.opus
│       ├── Salmo 96_instrumental.opus
│       ├── Salmo 97_instrumental.opus
│       ├── Salmo 98_instrumental.opus
│       ├── Salmo 99_instrumental.opus
│       └── Salmo 9_instrumental.opus
├── LICENSE
├── README.md
├── src
│   ├── app.rs
│   ├── components
│   │   ├── acoes_list.rs
│   │   ├── bcw_answer.rs
│   │   ├── bcw_list.rs
│   │   ├── biblia.rs
│   │   ├── cfw_list.rs
│   │   ├── cfw_sections.rs
│   │   ├── cmw_answer.rs
│   │   ├── cmw_list.rs
│   │   ├── diario_list.rs
│   │   ├── diario_view.rs
│   │   ├── estudo_menu.rs
│   │   ├── mod.rs
│   │   ├── piedade_menu.rs
│   │   ├── resolucoes_list.rs
│   │   ├── salmo_view.rs
│   │   ├── salterio_list.rs
│   │   └── symbols_menu.rs
│   ├── db.rs
│   ├── main.rs
│   ├── models.rs
│   ├── theme.rs
│   └── ui.rs
└── txt.txt

5 directories, 213 files

Conteúdo dos arquivos Rust:
-e 
# --- START OF FILE [./src/db.rs] ---
use crate::models::{
    Acao, CatecismoPergunta, CfwCapitulo, CfwSecao, EntradaDiario, Resolucao, Salmo, Versiculo,
};
use chrono::Local;
use rusqlite::{Connection, Result};

const CANON_DB_PATH: &str = "./data/canon.db";
const PIETY_DB_PATH: &str = "./data/piety.db";

// --- Funções do Banco 'canon.db' (Dados Públicos) ---

pub fn listar_salmos() -> Result<Vec<Salmo>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, referencia, melodia, tema, letra, instrumental, \"à_capela\" FROM salterio ORDER BY CAST(referencia AS INTEGER)")?;
    let salmos_iter = stmt.query_map([], |row| {
        Ok(Salmo {
            _id: row.get(0)?,
            referencia: row.get(1)?,
            melodia: row.get(2)?,
            _tema: row.get(3)?,
            letra: row.get(4)?,
            instrumental: row.get(5)?,
            a_capela: row.get(6)?,
        })
    })?;
    Ok(salmos_iter.collect::<Result<Vec<Salmo>>>()?)
}

pub fn listar_capitulos_cfw() -> Result<Vec<CfwCapitulo>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT DISTINCT chapter, title FROM cfw ORDER BY chapter")?;
    let cap_iter = stmt.query_map([], |row| {
        Ok(CfwCapitulo {
            chapter: row.get(0)?,
            title: row.get(1)?,
        })
    })?;
    Ok(cap_iter.collect::<Result<Vec<CfwCapitulo>>>()?)
}

pub fn ler_capitulo_biblia(nome_livro: &str, capitulo: i32) -> Result<Vec<Versiculo>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let book_id: i32 = conn.query_row(
        "SELECT id FROM book WHERE lower(name) = lower(?1)",
        [nome_livro],
        |row| row.get(0),
    )?;
    let mut stmt = conn.prepare("SELECT verse, text FROM verse WHERE book_id = ?1 AND chapter = ?2 AND version = 'ARA' ORDER BY verse")?;
    let verse_iter = stmt.query_map([book_id, capitulo], |row| {
        Ok(Versiculo {
            verse: row.get(0)?,
            text: row.get(1)?,
        })
    })?;
    Ok(verse_iter.collect::<Result<Vec<Versiculo>>>()?)
}

pub fn ler_secoes_cfw(numero_capitulo: i32) -> Result<Vec<CfwSecao>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let mut stmt =
        conn.prepare("SELECT section, text FROM cfw WHERE chapter = ? ORDER BY section")?;
    let secoes_iter = stmt.query_map([numero_capitulo], |row| {
        Ok(CfwSecao {
            section: row.get(0)?,
            text: row.get(1)?,
        })
    })?;
    Ok(secoes_iter.collect::<Result<Vec<CfwSecao>>>()?)
}

pub fn listar_perguntas_cmw() -> Result<Vec<CatecismoPergunta>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, question, answer FROM cmw ORDER BY id")?;
    let iter = stmt.query_map([], |row| {
        Ok(CatecismoPergunta {
            id: row.get(0)?,
            question: row.get(1)?,
            answer: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<CatecismoPergunta>>>()?)
}

pub fn listar_perguntas_bcw() -> Result<Vec<CatecismoPergunta>> {
    let conn = Connection::open(CANON_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, question, answer FROM bcw ORDER BY id")?;
    let iter = stmt.query_map([], |row| {
        Ok(CatecismoPergunta {
            id: row.get(0)?,
            question: row.get(1)?,
            answer: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<CatecismoPergunta>>>()?)
}

// --- Funções do Banco 'piety.db' (Dados Pessoais) ---

pub fn listar_entradas_diario() -> Result<Vec<EntradaDiario>> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, data, texto FROM diario ORDER BY data DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(EntradaDiario {
            _id: row.get(0)?,
            data: row.get(1)?,
            texto: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<EntradaDiario>>>()?)
}

pub fn criar_entrada_diario(texto: &str) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO diario (data, texto) VALUES (?1, ?2)",
        (data_atual, texto),
    )?;
    Ok(())
}

pub fn listar_acoes() -> Result<Vec<Acao>> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let mut stmt =
        conn.prepare("SELECT id, descricao, status FROM acoes ORDER BY status, id DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(Acao {
            id: row.get(0)?,
            descricao: row.get(1)?,
            status: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<Acao>>>()?)
}

pub fn criar_acao(descricao: &str) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO acoes (descricao, data_criacao) VALUES (?1, ?2)",
        (descricao, data_atual),
    )?;
    Ok(())
}

pub fn atualizar_status_acao(id: i32, status: &str) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    conn.execute("UPDATE acoes SET status = ?1 WHERE id = ?2", (status, id))?;
    Ok(())
}

pub fn deletar_acao(id: i32) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    conn.execute("DELETE FROM acoes WHERE id = ?1", [id])?;
    Ok(())
}

pub fn listar_resolucoes() -> Result<Vec<Resolucao>> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, texto FROM resolucoes ORDER BY id DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(Resolucao {
            id: row.get(0)?,
            texto: row.get(1)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<Resolucao>>>()?)
}

pub fn criar_resolucao(texto: &str) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO resolucoes (texto, data_criacao) VALUES (?1, ?2)",
        (texto, data_atual),
    )?;
    Ok(())
}

pub fn deletar_resolucao(id: i32) -> Result<()> {
    let conn = Connection::open(PIETY_DB_PATH)?;
    conn.execute("DELETE FROM resolucoes WHERE id = ?1", [id])?;
    Ok(())
}
-e 
# --- START OF FILE [./src/models.rs] ---
/// Representa um único registro da tabela 'salterio'.
#[derive(Clone, Debug)]
pub struct Salmo {
    pub _id: i32,
    pub referencia: String,
    pub melodia: Option<String>,
    pub _tema: Option<String>,
    pub letra: Option<String>, // Campo para a letra completa
    pub instrumental: Option<String>,
    pub a_capela: Option<String>,
}

/// Representa uma ação de santificação.
#[derive(Clone, Debug)]
pub struct Acao {
    pub id: i32,
    pub descricao: String,
    pub status: String,
}

/// Representa uma resolução pessoal.
#[derive(Clone, Debug)]
pub struct Resolucao {
    pub id: i32,
    pub texto: String,
}

/// Representa uma entrada do diário.
#[derive(Clone, Debug)]
pub struct EntradaDiario {
    pub _id: i32,
    pub data: String,
    pub texto: String,
}

/// Representa um capítulo da Confissão de Fé de Westminster.
#[derive(Clone, Debug)]
pub struct CfwCapitulo {
    pub chapter: i32,
    pub title: String,
}

/// Representa uma seção de um capítulo da CFW.
#[derive(Clone, Debug)]
pub struct CfwSecao {
    pub section: i32,
    pub text: String,
}

/// Representa uma pergunta e resposta de um catecismo.
#[derive(Clone, Debug)]
pub struct CatecismoPergunta {
    pub id: i32,
    pub question: String,
    pub answer: String,
}

/// Representa um único versículo da Bíblia.
#[derive(Clone, Debug)]
pub struct Versiculo {
    pub verse: i32,
    pub text: String,
}
-e 
# --- START OF FILE [./src/theme.rs] ---
use ratatui::style::{Color, Style, Stylize};

pub struct Theme {
    pub fg: Color,
    pub yellow: Color,
    pub green: Color,
    pub red: Color,
    pub dim_fg: Color,
    pub base_style: Style,
    pub header_style: Style,
    pub selected_style: Style,
}

impl Theme {
    pub fn new() -> Self {
        let bg = Color::Rgb(40, 40, 40);
        let fg = Color::Rgb(235, 219, 178);
        let highlight_bg = Color::Rgb(60, 56, 54);
        let yellow = Color::Rgb(250, 189, 47);
        let green = Color::Rgb(184, 187, 38);
        let blue = Color::Rgb(131, 165, 152);
        let red = Color::Rgb(251, 73, 52);
        let dim_fg = Color::Rgb(146, 131, 116);

        Self {
            fg,
            yellow,
            green,
            red,
            dim_fg,
            base_style: Style::default().bg(bg).fg(fg),
            header_style: Style::default().fg(blue).bold(),
            selected_style: Style::default().bg(highlight_bg).fg(fg),
        }
    }
}
-e 
# --- START OF FILE [./src/components/acoes_list.rs] ---
use super::{Action, Component, Module};
use crate::{app::App, db, models::Acao, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{
    layout::{Constraint, Rect},
    style::Stylize,
    text::Span,
    widgets::{HighlightSpacing, Paragraph, Row, Table, TableState},
    Frame,
};

enum InputMode { Normal, Editing }

pub struct AcoesListComponent {
    state: TableState,
    items: Vec<Acao>,
    input: String,
    input_mode: InputMode,
}

impl AcoesListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let items = db::listar_acoes().unwrap_or_default();
        if !items.is_empty() { state.select(Some(0)); }
        Self { state, items, input: String::new(), input_mode: InputMode::Normal }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.items.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.items.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_item_id(&self) -> Option<i32> {
        self.state.selected().and_then(|i| self.items.get(i)).map(|item| item.id)
    }
    fn refresh(&mut self) {
        self.items = db::listar_acoes().unwrap_or_default();
        if self.items.is_empty() { self.state.select(None); } else { self.state.select(Some(0)); }
    }
}

impl Component for AcoesListComponent {
    fn get_module(&self) -> Module { Module::Piedade }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match self.input_mode {
            InputMode::Normal => match key.code {
                KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
                KeyCode::Char('j') | KeyCode::Down => self.next(),
                KeyCode::Char('k') | KeyCode::Up => self.previous(),
                KeyCode::Char('n') => self.input_mode = InputMode::Editing,
                KeyCode::Char('d') => { if let Some(id) = self.get_selected_item_id() { db::deletar_acao(id).ok(); self.refresh(); } },
                KeyCode::Char('c') => { if let Some(id) = self.get_selected_item_id() { db::atualizar_status_acao(id, "completo").ok(); self.refresh(); } },
                KeyCode::Char('p') => { if let Some(id) = self.get_selected_item_id() { db::atualizar_status_acao(id, "pendente").ok(); self.refresh(); } },
                _ => {}
            },
            InputMode::Editing => match key.code {
                KeyCode::Enter => {
                    if !self.input.is_empty() { db::criar_acao(&self.input).ok(); self.input.clear(); self.refresh(); }
                    self.input_mode = InputMode::Normal;
                },
                KeyCode::Char(c) => self.input.push(c),
                KeyCode::Backspace => { self.input.pop(); },
                KeyCode::Esc => { self.input.clear(); self.input_mode = InputMode::Normal; },
                _ => {}
            },
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        self.render_table(frame, theme, chunks[1]);
        self.render_footer(frame, theme, chunks[2]);
    }
}

impl AcoesListComponent {
    fn render_table(&mut self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let h = Row::new(["", "ID", "Descrição"]).style(theme.header_style);
        let r = self.items.iter().map(|a| {
            let (icon, style) = if a.status == "completo" { ("[✓]", theme.base_style.fg(theme.green).dim()) } else { ("[ ]", theme.base_style) };
            Row::new(vec![ Span::styled(icon, style), Span::raw(a.id.to_string()), Span::raw(a.descricao.clone()) ]).style(style)
        });
        let t = Table::new(r, &[ Constraint::Length(3), Constraint::Length(4), Constraint::Min(20) ])
            .header(h)
            .block(crate::ui::styled_block("Ações de Santificação", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, area, &mut self.state);
    }
    fn render_footer(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let (text, title) = match self.input_mode {
            InputMode::Normal => ("[n] Nova | [c] Completar | [p] Pender | [d] Deletar | [v] Voltar", "Comandos"),
            InputMode::Editing => { frame.set_cursor(area.x + self.input.len() as u16 + 1, area.y + 1); (self.input.as_str(), "Nova Ação") }
        };
        frame.render_widget(Paragraph::new(text).block(crate::ui::styled_block(title, theme)), area);
    }
}
-e 
# --- START OF FILE [./src/components/diario_list.rs] ---
use super::{diario_view::DiarioViewComponent, Action, Component, Module};
use crate::{app::App, db, models::EntradaDiario, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{
    layout::{Constraint, Rect},
    widgets::{HighlightSpacing, Paragraph, Row, Table, TableState},
    Frame,
};

pub struct DiarioListComponent {
    state: TableState,
    entries: Vec<EntradaDiario>,
}

impl DiarioListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let entries = db::listar_entradas_diario().unwrap_or_default();
        if !entries.is_empty() { state.select(Some(0)); }
        Self { state, entries }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.entries.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.entries.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_entry(&self) -> Option<&EntradaDiario> {
        self.state.selected().and_then(|i| self.entries.get(i))
    }
    fn refresh_entries(&mut self) {
        self.entries = db::listar_entradas_diario().unwrap_or_default();
        if self.entries.is_empty() { self.state.select(None); }
        else { self.state.select(Some(0)); }
    }
}

impl Component for DiarioListComponent {
    fn get_module(&self) -> Module { Module::Piedade }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('n') => {
                let action = Some(Action::LaunchEditor);
                self.refresh_entries();
                return action;
            }
            KeyCode::Char('j') | KeyCode::Down => self.next(),
            KeyCode::Char('k') | KeyCode::Up => self.previous(),
            KeyCode::Enter => {
                if let Some(entry) = self.get_selected_entry() {
                    return Some(Action::Navigate(Box::new(DiarioViewComponent::new(entry.clone()))));
                }
            }
            KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        self.render_table(frame, theme, chunks[1]);
        self.render_footer(frame, theme, chunks[2]);
    }
}

impl DiarioListComponent {
    fn render_table(&mut self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let h = Row::new(["Data", "Início da Entrada"]).style(theme.header_style);
        let r = self.entries.iter().map(|e| {
            let preview = e.texto.chars().take(80).collect::<String>() + "...";
            Row::new(vec![e.data.clone(), preview])
        });
        let t = Table::new(r, &[Constraint::Length(20), Constraint::Min(20)])
            .header(h)
            .block(crate::ui::styled_block("Diário", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, area, &mut self.state);
    }
    fn render_footer(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let p = Paragraph::new("[n] Nova Entrada | [Enter] Ver | [v] Voltar")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(p, area);
    }
}
-e 
# --- START OF FILE [./src/components/mod.rs] ---
pub mod acoes_list;
pub mod bcw_answer;
pub mod bcw_list;
pub mod biblia;
pub mod cfw_list;
pub mod cfw_sections;
pub mod cmw_answer;
pub mod cmw_list;
pub mod diario_list;
pub mod diario_view;
pub mod estudo_menu;
pub mod piedade_menu;
pub mod resolucoes_list;
pub mod salmo_view;
pub mod salterio_list;
pub mod symbols_menu;

use crate::{app::App, theme::Theme};
use crossterm::event::KeyEvent;
use ratatui::Frame;

#[derive(Clone, Copy)]
pub enum Module {
    Canto,
    Piedade,
    Estudo,
}

pub enum Action {
    Quit,
    Pop,
    Navigate(Box<dyn Component>),
    LaunchEditor,
}

pub trait Component {
    fn get_module(&self) -> Module;
    fn handle_key_events(&mut self, key: KeyEvent, app: &mut App) -> Option<Action>;
    fn render(&mut self, frame: &mut Frame, theme: &Theme);
}
-e 
# --- START OF FILE [./src/components/resolucoes_list.rs] ---
use super::{Action, Component, Module};
use crate::{app::App, db, models::Resolucao, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{
    layout::{Constraint, Rect},
    widgets::{HighlightSpacing, Paragraph, Row, Table, TableState},
    Frame,
};

enum InputMode { Normal, Editing }

pub struct ResolucoesListComponent {
    state: TableState,
    items: Vec<Resolucao>,
    input: String,
    input_mode: InputMode,
}

impl ResolucoesListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let items = db::listar_resolucoes().unwrap_or_default();
        if !items.is_empty() { state.select(Some(0)); }
        Self { state, items, input: String::new(), input_mode: InputMode::Normal }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.items.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.items.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_item_id(&self) -> Option<i32> {
        self.state.selected().and_then(|i| self.items.get(i)).map(|item| item.id)
    }
    fn refresh(&mut self) {
        self.items = db::listar_resolucoes().unwrap_or_default();
        if self.items.is_empty() { self.state.select(None); } else { self.state.select(Some(0)); }
    }
}

impl Component for ResolucoesListComponent {
    fn get_module(&self) -> Module { Module::Piedade }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match self.input_mode {
            InputMode::Normal => match key.code {
                KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
                KeyCode::Char('j') | KeyCode::Down => self.next(),
                KeyCode::Char('k') | KeyCode::Up => self.previous(),
                KeyCode::Char('n') => self.input_mode = InputMode::Editing,
                KeyCode::Char('d') => { if let Some(id) = self.get_selected_item_id() { db::deletar_resolucao(id).ok(); self.refresh(); } }
                _ => {}
            },
            InputMode::Editing => match key.code {
                KeyCode::Enter => {
                    if !self.input.is_empty() { db::criar_resolucao(&self.input).ok(); self.input.clear(); self.refresh(); }
                    self.input_mode = InputMode::Normal;
                },
                KeyCode::Char(c) => self.input.push(c),
                KeyCode::Backspace => { self.input.pop(); },
                KeyCode::Esc => { self.input.clear(); self.input_mode = InputMode::Normal; },
                _ => {}
            },
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        self.render_table(frame, theme, chunks[1]);
        self.render_footer(frame, theme, chunks[2]);
    }
}

impl ResolucoesListComponent {
    fn render_table(&mut self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let h = Row::new(["ID", "Texto"]).style(theme.header_style);
        let r = self.items.iter().map(|item| Row::new(vec![item.id.to_string(), item.texto.clone()]));
        let t = Table::new(r, &[Constraint::Length(4), Constraint::Min(20)])
            .header(h)
            .block(crate::ui::styled_block("Minhas Resoluções", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, area, &mut self.state);
    }
    fn render_footer(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let (text, title) = match self.input_mode {
            InputMode::Normal => ("[n] Nova | [d] Deletar | [v] Voltar", "Comandos"),
            InputMode::Editing => { frame.set_cursor(area.x + self.input.len() as u16 + 1, area.y + 1); (self.input.as_str(), "Nova Resolução") }
        };
        frame.render_widget(Paragraph::new(text).block(crate::ui::styled_block(title, theme)), area);
    }
}
-e 
# --- START OF FILE [./src/components/salterio_list.rs] ---
use super::{
    estudo_menu::EstudoMenuComponent, piedade_menu::PiedadeMenuComponent,
    salmo_view::SalmoViewComponent, Action, Component, Module,
};
use crate::{app::App, db, models::Salmo, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{
    layout::{Constraint, Rect},
    widgets::{HighlightSpacing, Paragraph, Row, Table, TableState},
    Frame,
};

pub struct SalterioListComponent {
    pub state: TableState,
    pub items: Vec<Salmo>,
}

impl SalterioListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        state.select(Some(0));
        let items = db::listar_salmos().unwrap_or_default();
        Self { state, items }
    }
    pub fn next(&mut self) {
        let i = match self.state.selected() { Some(i) => if i >= self.items.len() - 1 { 0 } else { i + 1 }, None => 0 };
        self.state.select(Some(i));
    }
    pub fn previous(&mut self) {
        let i = match self.state.selected() { Some(i) => if i == 0 { self.items.len() - 1 } else { i - 1 }, None => 0 };
        self.state.select(Some(i));
    }
    pub fn selected_salmo(&self) -> Option<&Salmo> {
        self.items.get(self.state.selected().unwrap_or(0))
    }
}

impl Component for SalterioListComponent {
    fn get_module(&self) -> Module { Module::Canto }
    fn handle_key_events(&mut self, key: KeyEvent, app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('q') => return Some(Action::Quit),
            KeyCode::Char('j') | KeyCode::Down => self.next(),
            KeyCode::Char('k') | KeyCode::Up => self.previous(),
            KeyCode::Char('2') => return Some(Action::Navigate(Box::new(PiedadeMenuComponent))),
            KeyCode::Char('3') => return Some(Action::Navigate(Box::new(EstudoMenuComponent))),
            KeyCode::Enter => {
                if let Some(salmo) = self.selected_salmo() {
                    return Some(Action::Navigate(Box::new(SalmoViewComponent::new(salmo.clone()))));
                }
            }
            KeyCode::Char('t') => app.play_audio("instrumental", self.selected_salmo()),
            KeyCode::Char('c') => app.play_audio("a_capela", self.selected_salmo()),
            KeyCode::Char('s') => app.stop_audio(),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        self.render_table(frame, theme, chunks[1]);
        self.render_footer(frame, theme, chunks[2]);
    }
}

impl SalterioListComponent {
    fn render_table(&mut self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let h = Row::new(["Ref.", "Melodia"]).style(theme.header_style);
        let r = self.items.iter().map(|s| Row::new([s.referencia.clone(), s.melodia.clone().unwrap_or_default()]));
        let t = Table::new(r, &[Constraint::Percentage(40), Constraint::Percentage(60)])
            .header(h)
            .block(crate::ui::styled_block("Saltério", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, area, &mut self.state);
    }
    fn render_footer(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let p = Paragraph::new("[Enter] Ver Letra | [t] Tocar | [c] Cantar | [s] Parar")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(p, area);
    }
}
-e 
# --- START OF FILE [./src/components/bcw_list.rs] ---
use super::{bcw_answer::BcwAnswerComponent, Action, Component, Module};
use crate::{app::App, db, models::CatecismoPergunta, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{layout::Constraint, widgets::{HighlightSpacing, Paragraph, Row, Table, TableState}, Frame};

pub struct BcwListComponent {
    state: TableState,
    questions: Vec<CatecismoPergunta>,
}

impl BcwListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let questions = db::listar_perguntas_bcw().unwrap_or_default();
        if !questions.is_empty() { state.select(Some(0)); }
        Self { state, questions }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.questions.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.questions.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_item(&self) -> Option<&CatecismoPergunta> {
        self.state.selected().and_then(|i| self.questions.get(i))
    }
}

impl Component for BcwListComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('v') | KeyCode::Esc => Some(Action::Pop),
            KeyCode::Char('j') | KeyCode::Down => { self.next(); None },
            KeyCode::Char('k') | KeyCode::Up => { self.previous(); None },
            KeyCode::Enter => self.get_selected_item().map(|q| Action::Navigate(Box::new(BcwAnswerComponent::new(q.clone())))),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let h = Row::new(["Per.", "Pergunta"]).style(theme.header_style);
        let r = self.questions.iter().map(|p| Row::new([p.id.to_string(), p.question.clone()]));
        let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
            .header(h)
            .block(crate::ui::styled_block("Breve Catecismo", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, chunks[1], &mut self.state);
        let footer = Paragraph::new("[Enter] Ver | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/cfw_list.rs] ---
use super::{cfw_sections::CfwSectionsComponent, Action, Component, Module};
use crate::{app::App, db, models::CfwCapitulo, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{layout::Constraint, widgets::{HighlightSpacing, Paragraph, Row, Table, TableState}, Frame};

pub struct CfwListComponent {
    state: TableState,
    chapters: Vec<CfwCapitulo>,
}

impl CfwListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let chapters = db::listar_capitulos_cfw().unwrap_or_default();
        if !chapters.is_empty() { state.select(Some(0)); }
        Self { state, chapters }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.chapters.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.chapters.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_chapter(&self) -> Option<&CfwCapitulo> {
        self.state.selected().and_then(|i| self.chapters.get(i))
    }
}

impl Component for CfwListComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('v') | KeyCode::Esc => Some(Action::Pop),
            KeyCode::Char('j') | KeyCode::Down => { self.next(); None },
            KeyCode::Char('k') | KeyCode::Up => { self.previous(); None },
            KeyCode::Enter => self.get_selected_chapter().map(|c| Action::Navigate(Box::new(CfwSectionsComponent::new(c.chapter, c.title.clone())))),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let h = Row::new(["Cap.", "Título"]).style(theme.header_style);
        let r = self.chapters.iter().map(|c| Row::new([c.chapter.to_string(), c.title.clone()]));
        let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
            .header(h)
            .block(crate::ui::styled_block("Confissão de Fé", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, chunks[1], &mut self.state);
        let footer = Paragraph::new("[Enter] Ver | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/cmw_list.rs] ---
use super::{cmw_answer::CmwAnswerComponent, Action, Component, Module};
use crate::{app::App, db, models::CatecismoPergunta, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{layout::Constraint, widgets::{HighlightSpacing, Paragraph, Row, Table, TableState}, Frame};

pub struct CmwListComponent {
    state: TableState,
    questions: Vec<CatecismoPergunta>,
}

impl CmwListComponent {
    pub fn new() -> Self {
        let mut state = TableState::default();
        let questions = db::listar_perguntas_cmw().unwrap_or_default();
        if !questions.is_empty() { state.select(Some(0)); }
        Self { state, questions }
    }
    fn next(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i >= self.questions.len() - 1 { 0 } else { i + 1 });
        self.state.select(Some(i));
    }
    fn previous(&mut self) {
        let i = self.state.selected().map_or(0, |i| if i == 0 { self.questions.len() - 1 } else { i - 1 });
        self.state.select(Some(i));
    }
    fn get_selected_item(&self) -> Option<&CatecismoPergunta> {
        self.state.selected().and_then(|i| self.questions.get(i))
    }
}

impl Component for CmwListComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('v') | KeyCode::Esc => Some(Action::Pop),
            KeyCode::Char('j') | KeyCode::Down => { self.next(); None },
            KeyCode::Char('k') | KeyCode::Up => { self.previous(); None },
            KeyCode::Enter => self.get_selected_item().map(|q| Action::Navigate(Box::new(CmwAnswerComponent::new(q.clone())))),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let h = Row::new(["Per.", "Pergunta"]).style(theme.header_style);
        let r = self.questions.iter().map(|p| Row::new([p.id.to_string(), p.question.clone()]));
        let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
            .header(h)
            .block(crate::ui::styled_block("Catecismo Maior", theme))
            .highlight_style(theme.selected_style)
            .highlight_spacing(HighlightSpacing::Always);
        frame.render_stateful_widget(t, chunks[1], &mut self.state);
        let footer = Paragraph::new("[Enter] Ver | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/bcw_answer.rs] ---
use super::{Action, Component, Module};
use crate::{models::CatecismoPergunta, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{style::Stylize, text::{Line, Span}, widgets::{Paragraph, Wrap}, Frame};

pub struct BcwAnswerComponent {
    question: CatecismoPergunta,
    scroll: u16,
}

impl BcwAnswerComponent {
    pub fn new(question: CatecismoPergunta) -> Self { Self { question, scroll: 0 } }
}

impl Component for BcwAnswerComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut crate::app::App) -> Option<Action> {
        match key.code {
            KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
            KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
            KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let title = format!("BCW Pergunta {}", self.question.id);
        let txt = vec![
            Line::from(vec![Span::styled("P: ", theme.header_style.bold()), Span::raw(&self.question.question)]),
            Line::from(""),
            Line::from(vec![Span::styled("R: ", theme.header_style.bold()), Span::raw(&self.question.answer)]),
        ];
        let p = Paragraph::new(txt).wrap(Wrap { trim: true }).scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme)).style(theme.base_style);
        frame.render_widget(p, chunks[1]);
        let footer = Paragraph::new("[j/k] Rolar | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/cmw_answer.rs] ---
use super::{Action, Component, Module};
use crate::{models::CatecismoPergunta, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{style::Stylize, text::{Line, Span}, widgets::{Paragraph, Wrap}, Frame};

pub struct CmwAnswerComponent {
    question: CatecismoPergunta,
    scroll: u16,
}

impl CmwAnswerComponent {
    pub fn new(question: CatecismoPergunta) -> Self { Self { question, scroll: 0 } }
}

impl Component for CmwAnswerComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut crate::app::App) -> Option<Action> {
        match key.code {
            KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
            KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
            KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let title = format!("CMW Pergunta {}", self.question.id);
        let txt = vec![
            Line::from(vec![Span::styled("P: ", theme.header_style.bold()), Span::raw(&self.question.question)]),
            Line::from(""),
            Line::from(vec![Span::styled("R: ", theme.header_style.bold()), Span::raw(&self.question.answer)]),
        ];
        let p = Paragraph::new(txt).wrap(Wrap { trim: true }).scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme)).style(theme.base_style);
        frame.render_widget(p, chunks[1]);
        let footer = Paragraph::new("[j/k] Rolar | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/biblia.rs] ---
use super::{Action, Component, Module};
use crate::{app::{App, MessageType}, db, models::Versiculo, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{
    layout::Rect,
    widgets::{Paragraph, Wrap},
    Frame,
};

enum InputMode { Normal, Editing }

pub struct BibliaComponent {
    verses: Vec<Versiculo>,
    reference: String,
    scroll: u16,
    input: String,
    input_mode: InputMode,
    status_message: (String, MessageType),
}

impl BibliaComponent {
    pub fn new() -> Self {
        Self {
            verses: Vec::new(),
            reference: "Nenhuma passagem".to_string(),
            scroll: 0,
            input: String::new(),
            input_mode: InputMode::Normal,
            status_message: ("Use [e] para buscar. Ex: ler genesis 1".to_string(), MessageType::Info),
        }
    }
    fn submit_command(&mut self) {
        let command_text = self.input.trim();
        if command_text.is_empty() { return; }
        let parts: Vec<_> = command_text.split_whitespace().collect();
        if parts.get(0) == Some(&"ler") && parts.len() == 3 {
            let book = parts[1];
            if let Ok(chapter) = parts[2].parse::<i32>() {
                match db::ler_capitulo_biblia(book, chapter) {
                    Ok(v) if !v.is_empty() => {
                        self.verses = v;
                        self.reference = format!("{} {}", book, chapter).to_uppercase();
                        self.status_message = (format!("Carregado: {}.", self.reference), MessageType::Success);
                        self.scroll = 0;
                    }
                    Ok(_) => self.status_message = (format!("Nenhum resultado para '{} {}'.", book, chapter), MessageType::Info),
                    Err(_) => self.status_message = (format!("Erro: Livro '{}' não encontrado.", book), MessageType::Error),
                }
            } else { self.status_message = ("Erro: Capítulo inválido.".to_string(), MessageType::Error); }
        } else { self.status_message = ("Comando inválido. Use: ler <livro> <capítulo>".to_string(), MessageType::Error); }
    }
}

impl Component for BibliaComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match self.input_mode {
            InputMode::Normal => match key.code {
                KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
                KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
                KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
                KeyCode::Char('e') => self.input_mode = InputMode::Editing,
                _ => {}
            },
            InputMode::Editing => match key.code {
                KeyCode::Enter => { self.submit_command(); self.input.clear(); self.input_mode = InputMode::Normal; },
                KeyCode::Char(c) => self.input.push(c),
                KeyCode::Backspace => { self.input.pop(); },
                KeyCode::Esc => { self.input.clear(); self.input_mode = InputMode::Normal; },
                _ => {}
            }
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        self.render_view(frame, theme, chunks[1]);
        self.render_footer(frame, theme, chunks[2]);
    }
}

impl BibliaComponent {
    fn render_view(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let text = if self.verses.is_empty() { "\n\n\nUse [e] para buscar uma passagem.".to_string() }
        else { self.verses.iter().map(|v| format!("[{}] {}\n", v.verse, v.text)).collect() };
        let title = format!("Bíblia: {}", self.reference);
        let p = Paragraph::new(text)
            .wrap(Wrap { trim: false })
            .scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme))
            .style(theme.base_style);
        frame.render_widget(p, area);
    }
    fn render_footer(&self, frame: &mut Frame, theme: &Theme, area: Rect) {
        let (block_title, text, style) = match self.input_mode {
            InputMode::Editing => {
                frame.set_cursor(area.x + self.input.len() as u16 + 1, area.y + 1);
                ("Comando", self.input.as_str(), theme.base_style)
            },
            InputMode::Normal => {
                let (status_text, msg_type) = &self.status_message;
                let color = match msg_type {
                    MessageType::Success => theme.green, MessageType::Error => theme.red, MessageType::Info => theme.fg,
                };
                ("Status", status_text.as_str(), theme.base_style.fg(color))
            }
        };
        let p = Paragraph::new(text).style(style).block(crate::ui::styled_block(block_title, theme));
        frame.render_widget(p, area);
    }
}
-e 
# --- START OF FILE [./src/components/cfw_sections.rs] ---
use super::{Action, Component, Module};
use crate::{app::App, db, models::CfwSecao, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::{Paragraph, Wrap}, Frame};

pub struct CfwSectionsComponent {
    title: String,
    sections: Vec<CfwSecao>,
    scroll: u16,
}

impl CfwSectionsComponent {
    pub fn new(chapter_number: i32, title: String) -> Self {
        Self { title, sections: db::ler_secoes_cfw(chapter_number).unwrap_or_default(), scroll: 0 }
    }
}

impl Component for CfwSectionsComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
            KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
            KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let text: String = self.sections.iter().map(|s| format!("{}. {}\n\n", s.section, s.text)).collect();
        let title = format!("CFW: {}", self.title);
        let p = Paragraph::new(text).wrap(Wrap { trim: false }).scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme)).style(theme.base_style);
        frame.render_widget(p, chunks[1]);
        let footer = Paragraph::new("[j/k] Rolar | [v] Voltar").block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/diario_view.rs] ---
use super::{Action, Component, Module};
use crate::{models::EntradaDiario, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::{Paragraph, Wrap}, Frame};

pub struct DiarioViewComponent {
    entry: EntradaDiario,
    scroll: u16,
}

impl DiarioViewComponent {
    pub fn new(entry: EntradaDiario) -> Self { Self { entry, scroll: 0 } }
}

impl Component for DiarioViewComponent {
    fn get_module(&self) -> Module { Module::Piedade }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut crate::app::App) -> Option<Action> {
        match key.code {
            KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
            KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
            KeyCode::Char('v') | KeyCode::Esc => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let title = format!("Diário - {}", self.entry.data);
        let p = Paragraph::new(self.entry.texto.as_str())
            .wrap(Wrap { trim: true })
            .scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme))
            .style(theme.base_style);
        frame.render_widget(p, chunks[1]);
        let footer = Paragraph::new("[j/k] Rolar | [v] Voltar")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/estudo_menu.rs] ---
use super::{biblia::BibliaComponent, symbols_menu::SymbolsMenuComponent, Action, Component, Module};
use crate::{app::App, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::Paragraph, Frame};

pub struct EstudoMenuComponent;

impl Component for EstudoMenuComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('1') => Some(Action::Navigate(Box::new(SymbolsMenuComponent))),
            KeyCode::Char('2') => Some(Action::Navigate(Box::new(BibliaComponent::new()))),
            KeyCode::Esc | KeyCode::Char('v') => Some(Action::Pop),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        frame.render_widget(
            Paragraph::new("\n\n   [1] Símbolos de Fé\n\n   [2] Bíblia")
                .block(crate::ui::styled_block("Estudo", theme))
                .style(theme.base_style),
            chunks[1],
        );
        let footer = Paragraph::new("Use os números para selecionar ou [v] para voltar.")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/piedade_menu.rs] ---
use super::{
    acoes_list::AcoesListComponent, diario_list::DiarioListComponent,
    resolucoes_list::ResolucoesListComponent, Action, Component, Module,
};
use crate::{app::App, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::Paragraph, Frame};

pub struct PiedadeMenuComponent;

impl Component for PiedadeMenuComponent {
    fn get_module(&self) -> Module { Module::Piedade }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('1') => Some(Action::Navigate(Box::new(DiarioListComponent::new()))),
            KeyCode::Char('2') => Some(Action::Navigate(Box::new(AcoesListComponent::new()))),
            KeyCode::Char('3') => Some(Action::Navigate(Box::new(ResolucoesListComponent::new()))),
            KeyCode::Esc | KeyCode::Char('v') => Some(Action::Pop),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        frame.render_widget(
            Paragraph::new("\n [1] Diário\n\n [2] Ações de Santificação\n\n [3] Resoluções")
                .block(crate::ui::styled_block("Piedade", theme))
                .style(theme.base_style),
            chunks[1],
        );
        let footer = Paragraph::new("Use os números para selecionar ou [v] para voltar.")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/salmo_view.rs] ---
use super::{Action, Component, Module};
use crate::{models::Salmo, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::{Paragraph, Wrap}, Frame};

pub struct SalmoViewComponent {
    pub salmo: Salmo,
    pub scroll: u16,
}

impl SalmoViewComponent {
    pub fn new(salmo: Salmo) -> Self { Self { salmo, scroll: 0 } }
}

impl Component for SalmoViewComponent {
    fn get_module(&self) -> Module { Module::Canto }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut crate::app::App) -> Option<Action> {
        match key.code {
            KeyCode::Char('j') | KeyCode::Down => self.scroll = self.scroll.saturating_add(1),
            KeyCode::Char('k') | KeyCode::Up => self.scroll = self.scroll.saturating_sub(1),
            KeyCode::Esc | KeyCode::Char('v') => return Some(Action::Pop),
            _ => {}
        }
        None
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let txt = self.salmo.letra.as_deref().unwrap_or("Letra não disponível.");
        let title = format!("Salmo - {}", self.salmo.referencia);
        let p = Paragraph::new(txt)
            .wrap(Wrap { trim: true })
            .scroll((self.scroll, 0))
            .block(crate::ui::styled_block(&title, theme))
            .style(theme.base_style);
        frame.render_widget(p, chunks[1]);
        let footer = Paragraph::new("[j/k] Rolar | [v] Voltar")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/components/symbols_menu.rs] ---
use super::{
    bcw_list::BcwListComponent, cfw_list::CfwListComponent, cmw_list::CmwListComponent, Action,
    Component, Module,
};
use crate::{app::App, theme::Theme};
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::{widgets::Paragraph, Frame};

pub struct SymbolsMenuComponent;

impl Component for SymbolsMenuComponent {
    fn get_module(&self) -> Module { Module::Estudo }
    fn handle_key_events(&mut self, key: KeyEvent, _app: &mut App) -> Option<Action> {
        match key.code {
            KeyCode::Char('1') => Some(Action::Navigate(Box::new(CfwListComponent::new()))),
            KeyCode::Char('2') => Some(Action::Navigate(Box::new(CmwListComponent::new()))),
            KeyCode::Char('3') => Some(Action::Navigate(Box::new(BcwListComponent::new()))),
            KeyCode::Esc | KeyCode::Char('v') => Some(Action::Pop),
            _ => None,
        }
    }
    fn render(&mut self, frame: &mut Frame, theme: &Theme) {
        let chunks = crate::ui::get_layout_chunks(frame.size());
        let menu_text = "\n   [1] Confissão de Fé\n\n   [2] Catecismo Maior\n\n   [3] Breve Catecismo";
        frame.render_widget(
            Paragraph::new(menu_text)
                .block(crate::ui::styled_block("Símbolos de Fé", theme))
                .style(theme.base_style),
            chunks[1],
        );
        let footer = Paragraph::new("[1], [2], [3] Selecionar | [v] Voltar")
            .block(crate::ui::styled_block("Ajuda", theme));
        frame.render_widget(footer, chunks[2]);
    }
}
-e 
# --- START OF FILE [./src/app.rs] ---
use crate::{components::Component, models::Salmo, theme::Theme};
use std::{
    path::Path,
    process::{Child, Command},
};

pub struct App {
    pub should_quit: bool,
    pub theme: Theme,
    pub audio_process: Option<Child>,
    pub component_stack: Vec<Box<dyn Component>>,
}

impl App {
    pub fn new() -> Self {
        Self {
            should_quit: false,
            theme: Theme::new(),
            audio_process: None,
            component_stack: Vec::new(),
        }
    }

    pub fn push_component(&mut self, component: Box<dyn Component>) {
        self.component_stack.push(component);
    }

    pub fn pop_component(&mut self) {
        self.component_stack.pop();
    }

    pub fn quit(&mut self) {
        self.should_quit = true;
    }

    // --- Métodos de Áudio ---
    pub fn stop_audio(&mut self) {
        if let Some(mut child) = self.audio_process.take() {
            if child.kill().is_ok() {
                let _ = child.wait();
            }
        }
    }

    pub fn play_audio(&mut self, audio_type: &str, salmo: Option<&Salmo>) {
        self.stop_audio();
        let filename = salmo.and_then(|s| {
            match audio_type {
                "instrumental" => s.instrumental.as_ref(),
                "a_capela" => s.a_capela.as_ref(),
                _ => None,
            }
            .cloned()
        });
        if let Some(name) = filename {
            let path = Path::new("./data/saltério").join(&name);
            if path.exists() {
                if let Ok(child) = Command::new("mpv")
                    .args(["--no-video", "--really-quiet", path.to_str().unwrap()])
                    .spawn()
                {
                    self.audio_process = Some(child);
                }
            }
        }
    }

    pub fn check_audio_process(&mut self) {
        if let Some(child) = self.audio_process.as_mut() {
            if let Ok(Some(_)) = child.try_wait() {
                self.audio_process.take();
            }
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub enum MessageType {
    Info,
    Success,
    Error,
}
-e 
# --- START OF FILE [./src/main.rs] ---
mod app;
mod components;
mod db;
mod models;
mod theme;
mod ui;
use crate::{
    app::App,
    components::{salterio_list::SalterioListComponent, Action},
};
use crossterm::{
    event::{self, Event},
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    ExecutableCommand,
};
use ratatui::{backend::CrosstermBackend, Terminal};
use rusqlite::Connection;
use std::io::{self, stdout, Read, Stdout};
use std::path::Path;
use std::time::Duration;
use tempfile::NamedTempFile;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    criar_banco_se_nao_existir();
    let mut terminal = setup_terminal()?;
    let mut app = App::new();
    app.push_component(Box::new(SalterioListComponent::new()));
    let run_result = run(&mut terminal, &mut app);
    app.stop_audio();
    restore_terminal()?;
    run_result?;
    Ok(())
}

fn run(terminal: &mut Terminal<CrosstermBackend<Stdout>>, app: &mut App) -> io::Result<()> {
    while !app.should_quit {
        terminal.draw(|frame| ui::render(frame, app))?;
        app.check_audio_process();
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if let Some(mut component) = app.component_stack.pop() {
                    let action = component.handle_key_events(key, app);
                    
                    if let Some(action) = action {
                        match action {
                            Action::Quit => app.quit(),
                            Action::Pop => (), // Component is not pushed back
                            Action::Navigate(new_component) => {
                                app.component_stack.push(component);
                                app.component_stack.push(new_component);
                            }
                            Action::LaunchEditor => {
                                app.component_stack.push(component);
                                restore_terminal()?;
                                let _ = launch_editor_and_save_entry();
                                enable_raw_mode()?;
                                stdout().execute(EnterAlternateScreen)?;
                                terminal.clear()?;
                            }
                        }
                    } else {
                        // No action, push the component back
                        app.component_stack.push(component);
                    }
                }
            }
        }
        if app.component_stack.is_empty() {
            app.quit();
        }
    }
    Ok(())
}

fn launch_editor_and_save_entry() -> io::Result<()> {
    use std::{fs, process::Command};
    let editor = std::env::var("EDITOR").unwrap_or_else(|_| "nano".to_string());
    let temp_file = NamedTempFile::new()?;
    let temp_path = temp_file.path();
    if !Command::new(&editor).arg(temp_path).status()?.success() {
        return Ok(());
    }
    let mut contents = String::new();
    fs::File::open(temp_path)?.read_to_string(&mut contents)?;
    if !contents.trim().is_empty() {
        db::criar_entrada_diario(&contents).ok();
    }
    Ok(())
}

fn setup_terminal() -> io::Result<Terminal<CrosstermBackend<Stdout>>> {
    enable_raw_mode()?;
    stdout().execute(EnterAlternateScreen)?;
    Terminal::new(CrosstermBackend::new(stdout()))
}
fn restore_terminal() -> io::Result<()> {
    disable_raw_mode()?;
    stdout().execute(LeaveAlternateScreen)?;
    Ok(())
}
fn criar_banco_se_nao_existir() {
    let caminho = "data/piety.db";
    if Path::new(caminho).exists() { return; }
    std::fs::create_dir_all("data").unwrap();
    let conexao = Connection::open(caminho).unwrap();
    conexao.execute_batch(
        "
        CREATE TABLE diario(id INTEGER PRIMARY KEY, data TEXT, texto TEXT);
        CREATE TABLE acoes(id INTEGER PRIMARY KEY, descricao TEXT, status TEXT, data_criacao TEXT);
        CREATE TABLE resolucoes(id INTEGER PRIMARY KEY, texto TEXT, data_criacao TEXT);
        CREATE TABLE sermoes(id INTEGER PRIMARY KEY, titulo TEXT, tema TEXT, pregador TEXT, local TEXT, data TEXT, link TEXT, passagem_principal TEXT);
        CREATE TABLE notas_estudo(id INTEGER PRIMARY KEY, referencia_biblica TEXT, texto TEXT, data_criacao TEXT);
        ").unwrap();
}
-e 
# --- START OF FILE [./src/ui.rs] ---
use crate::{app::App, components::Module, theme::Theme};
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Style, Stylize},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
    Frame,
};
use std::process::Child;

/// Retorna as áreas de layout principais: [menu, conteúdo, rodapé]
pub fn get_layout_chunks(area: Rect) -> Vec<Rect> {
    let layout = Layout::new(
        Direction::Vertical,
        [Constraint::Min(0), Constraint::Length(3)],
    )
    .split(area);

    let top_layout = Layout::new(
        Direction::Horizontal,
        [Constraint::Percentage(30), Constraint::Percentage(70)],
    )
    .split(layout[0]);

    vec![top_layout[0], top_layout[1], layout[1]]
}

/// Função de renderização principal, chamada a cada ciclo do loop.
pub fn render(frame: &mut Frame, app: &mut App) {
    if let Some(mut component) = app.component_stack.pop() {
        let theme = &app.theme;
        let audio_process = &app.audio_process;
        let active_module = component.get_module();

        // Renderiza o layout base
        frame.render_widget(Block::default().style(theme.base_style), frame.size());
        let chunks = get_layout_chunks(frame.size());
        render_main_menu(theme, audio_process, frame, chunks[0], active_module);

        // Delega a renderização do conteúdo ao componente
        component.render(frame, theme);

        // Coloca o componente de volta
        app.component_stack.push(component);
    }
}

/// Renderiza o painel de navegação esquerdo, destacando o módulo ativo.
fn render_main_menu(
    theme: &Theme,
    audio_process: &Option<Child>,
    frame: &mut Frame,
    area: Rect,
    active_module: Module,
) {
    let canto_style = if matches!(active_module, Module::Canto) {
        theme.selected_style
    } else {
        theme.base_style
    };
    let piedade_style = if matches!(active_module, Module::Piedade) {
        theme.selected_style
    } else {
        theme.base_style
    };
    let estudo_style = if matches!(active_module, Module::Estudo) {
        theme.selected_style
    } else {
        theme.base_style
    };

    let audio_indicator = if audio_process.is_some() { "[♫]" } else { "   " };
    let canto_label = format!("{} [1] Canto  ", audio_indicator);

    let nav_text = vec![
        Line::from("Navegação:"),
        Line::from(""),
        Line::from(Span::styled(canto_label, canto_style)),
        Line::from(Span::styled("   [2] Piedade", piedade_style)),
        Line::from(Span::styled("   [3] Estudo ", estudo_style)),
    ];

    let paragraph = Paragraph::new(nav_text)
        .block(
            Block::default()
                .title("Menu Principal")
                .borders(Borders::ALL),
        )
        .style(theme.base_style);
    frame.render_widget(paragraph, area);
}

/// Helper para criar um bloco estilizado padrão.
pub fn styled_block<'a>(title: &'a str, theme: &Theme) -> Block<'a> {
    Block::default()
        .title(Span::styled(title, Style::default().fg(theme.green).bold()))
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.dim_fg))
}

Esquema dos arquivos SQLite:
-e 
Banco de Dados: ./data/canon.db
CREATE TABLE salterio(
  id INT,
  referencia TEXT,
  metrica TEXT,
  melodia TEXT,
  compositor TEXT,
  harmonizacao TEXT,
  letra TEXT,
  instrumental TEXT,
  "à_capela" TEXT,
  tema TEXT
);
CREATE TABLE cfw(
  id INT,
  chapter INT,
  section INT,
  title TEXT,
  text TEXT
);
CREATE TABLE cmw(id INT,question TEXT,answer TEXT);
CREATE TABLE bcw(id INT,question TEXT,answer TEXT);
CREATE TABLE testament(id INT,name TEXT);
CREATE TABLE book(
  id INT,
  book_reference_id INT,
  testament_reference_id INT,
  name TEXT
);
CREATE TABLE verse(
  id INT,
  book_id INT,
  chapter INT,
  verse INT,
  text TEXT,
  version TEXT
);
CREATE TABLE texts(id INT,document TEXT,location TEXT);
CREATE TABLE proof_texts(
  id INT,
  text_id INT,
  book_id INT,
  chapter INT,
  verse INT
);
-e -e 
-e 
Banco de Dados: ./data/piety.db
CREATE TABLE diario(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              data TEXT,
              texto TEXT
            );
CREATE TABLE sqlite_sequence(name,seq);
CREATE TABLE acoes(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              descricao TEXT,
              status TEXT,
              data_criacao TEXT
            );
CREATE TABLE resolucoes(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              texto TEXT,
              data_criacao TEXT
            );
CREATE TABLE sermoes(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              titulo TEXT,
              tema TEXT,
              pregador TEXT,
              local TEXT,
              data TEXT,
              link TEXT,
              passagem_principal TEXT
            );
CREATE TABLE notas_estudo(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              referencia_biblica TEXT,
              texto TEXT,
              data_criacao TEXT
            );
-e -e 
