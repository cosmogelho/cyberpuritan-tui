Estrutura de diretórios:
./
├── Cargo.toml
├── data
│   ├── dados.db
│   └── saltério
│       ├── converter_para_opus.sh
│       ├── Salmo 100_instrumental.opus
│       ├── Salmo 101_instrumental.opus
│       ├── Salmo 102_instrumental.opus
│       ├── Salmo 103_instrumental.opus
│       ├── Salmo 104_instrumental.opus
│       ├── Salmo 105_instrumental.opus
│       ├── Salmo 106_instrumental.opus
│       ├── Salmo 107_instrumental.opus
│       ├── Salmo 108_instrumental.opus
│       ├── Salmo 109_instrumental.opus
│       ├── Salmo 10_instrumental.opus
│       ├── Salmo 110_a_capela.opus
│       ├── Salmo 110_instrumental.opus
│       ├── Salmo 111_instrumental.opus
│       ├── Salmo 112_instrumental.opus
│       ├── Salmo 113_instrumental.opus
│       ├── Salmo 114_instrumental.opus
│       ├── Salmo 115_instrumental.opus
│       ├── Salmo 116_instrumental.opus
│       ├── Salmo 117_instrumental.opus
│       ├── Salmo 118_instrumental.opus
│       ├── Salmo 119 105-112_instrumental.opus
│       ├── Salmo 119 113-120_instrumental.opus
│       ├── Salmo 119 121-128_instrumental.opus
│       ├── Salmo 119 129-136_instrumental.opus
│       ├── Salmo 119 137-144_instrumental.opus
│       ├── Salmo 119 145-152_instrumental.opus
│       ├── Salmo 119 153-160_instrumental.opus
│       ├── Salmo 119 161-168_instrumental.opus
│       ├── Salmo 119 169-176_instrumental.opus
│       ├── Salmo 119 17-24_instrumental.opus
│       ├── Salmo 119 1-8_instrumental.opus
│       ├── Salmo 119 25-32_instrumental.opus
│       ├── Salmo 119 33-40_instrumental.opus
│       ├── Salmo 119 41-48_instrumental.opus
│       ├── Salmo 119 49-56_instrumental.opus
│       ├── Salmo 119 57-64_instrumental.opus
│       ├── Salmo 119 65-72_instrumental.opus
│       ├── Salmo 119 73-80_instrumental.opus
│       ├── Salmo 119 81-88_instrumental.opus
│       ├── Salmo 119 89-96_instrumental.opus
│       ├── Salmo 119 9-16_instrumental.opus
│       ├── Salmo 119 97-104_instrumental.opus
│       ├── Salmo 11_instrumental.opus
│       ├── Salmo 120_instrumental.opus
│       ├── Salmo 121_instrumental.opus
│       ├── Salmo 122_instrumental.opus
│       ├── Salmo 123_instrumental.opus
│       ├── Salmo 124_instrumental.opus
│       ├── Salmo 125_instrumental.opus
│       ├── Salmo 126_instrumental.opus
│       ├── Salmo 127_instrumental.opus
│       ├── Salmo 128_instrumental.opus
│       ├── Salmo 129_instrumental.opus
│       ├── Salmo 12_a_capela.opus
│       ├── Salmo 12_instrumental.opus
│       ├── Salmo 130_instrumental.opus
│       ├── Salmo 131_instrumental.opus
│       ├── Salmo 132_instrumental.opus
│       ├── Salmo 133_instrumental.opus
│       ├── Salmo 134_instrumental.opus
│       ├── Salmo 135_instrumental.opus
│       ├── Salmo 136_instrumental.opus
│       ├── Salmo 137_instrumental.opus
│       ├── Salmo 138_instrumental.opus
│       ├── Salmo 139_instrumental.opus
│       ├── Salmo 13_instrumental.opus
│       ├── Salmo 140_instrumental.opus
│       ├── Salmo 141_instrumental.opus
│       ├── Salmo 142_instrumental.opus
│       ├── Salmo 143_instrumental.opus
│       ├── Salmo 144_instrumental.opus
│       ├── Salmo 145_instrumental.opus
│       ├── Salmo 146_instrumental.opus
│       ├── Salmo 147_instrumental.opus
│       ├── Salmo 148_instrumental.opus
│       ├── Salmo 149_instrumental.opus
│       ├── Salmo 14_a_capela.opus
│       ├── Salmo 14_instrumental.opus
│       ├── Salmo 150_instrumental.opus
│       ├── Salmo 15_a_capela.opus
│       ├── Salmo 15_instrumental.opus
│       ├── Salmo 16_instrumental.opus
│       ├── Salmo 17_instrumental.opus
│       ├── Salmo 18_instrumental.opus
│       ├── Salmo 19_instrumental.opus
│       ├── Salmo 1_a_capela.opus
│       ├── Salmo 1_instrumental.opus
│       ├── Salmo 20_instrumental.opus
│       ├── Salmo 21_instrumental.opus
│       ├── Salmo 22_instrumental.opus
│       ├── Salmo 23_instrumental.opus
│       ├── Salmo 24_instrumental.opus
│       ├── Salmo 25_instrumental.opus
│       ├── Salmo 26_instrumental.opus
│       ├── Salmo 27_instrumental.opus
│       ├── Salmo 28_instrumental.opus
│       ├── Salmo 29_a_capela.opus
│       ├── Salmo 29_instrumental.opus
│       ├── Salmo 2_a_capela.opus
│       ├── Salmo 2_instrumental.opus
│       ├── Salmo 30_instrumental.opus
│       ├── Salmo 31_instrumental.opus
│       ├── Salmo 32_a_capela.opus
│       ├── Salmo 32_instrumental.opus
│       ├── Salmo 33_instrumental.opus
│       ├── Salmo 34_instrumental.opus
│       ├── Salmo 35_instrumental.opus
│       ├── Salmo 36_instrumental.opus
│       ├── Salmo 37_instrumental.opus
│       ├── Salmo 38_instrumental.opus
│       ├── Salmo 39_instrumental.opus
│       ├── Salmo 3_a_capela.opus
│       ├── Salmo 3_instrumental.opus
│       ├── Salmo 40_instrumental.opus
│       ├── Salmo 41_instrumental.opus
│       ├── Salmo 42_instrumental.opus
│       ├── Salmo 43_instrumental.opus
│       ├── Salmo 44_instrumental.opus
│       ├── Salmo 45_instrumental.opus
│       ├── Salmo 46_instrumental.opus
│       ├── Salmo 47_instrumental.opus
│       ├── Salmo 48_instrumental.opus
│       ├── Salmo 49_instrumental.opus
│       ├── Salmo 4_instrumental.opus
│       ├── Salmo 50_instrumental.opus
│       ├── Salmo 51_instrumental.opus
│       ├── Salmo 52_instrumental.opus
│       ├── Salmo 53_a_capela.opus
│       ├── Salmo 53_instrumental.opus
│       ├── Salmo 54_instrumental.opus
│       ├── Salmo 55_instrumental.opus
│       ├── Salmo 56_instrumental.opus
│       ├── Salmo 57_instrumental.opus
│       ├── Salmo 58_instrumental.opus
│       ├── Salmo 59_instrumental.opus
│       ├── Salmo 5_a_capela.opus
│       ├── Salmo 5_instrumental.opus
│       ├── Salmo 60_instrumental.opus
│       ├── Salmo 61_instrumental.opus
│       ├── Salmo 62_instrumental.opus
│       ├── Salmo 63_instrumental.opus
│       ├── Salmo 64_instrumental.opus
│       ├── Salmo 65_instrumental.opus
│       ├── Salmo 66_instrumental.opus
│       ├── Salmo 67_instrumental.opus
│       ├── Salmo 68_instrumental.opus
│       ├── Salmo 69_instrumental.opus
│       ├── Salmo 6_instrumental.opus
│       ├── Salmo 70_instrumental.opus
│       ├── Salmo 71_instrumental.opus
│       ├── Salmo 72_instrumental.opus
│       ├── Salmo 73_instrumental.opus
│       ├── Salmo 74_instrumental.opus
│       ├── Salmo 75_instrumental.opus
│       ├── Salmo 76_instrumental.opus
│       ├── Salmo 77_instrumental.opus
│       ├── Salmo 78_instrumental.opus
│       ├── Salmo 79_instrumental.opus
│       ├── Salmo 7_instrumental.opus
│       ├── Salmo 80_instrumental.opus
│       ├── Salmo 81_instrumental.opus
│       ├── Salmo 82_instrumental.opus
│       ├── Salmo 83_instrumental.opus
│       ├── Salmo 84_instrumental.opus
│       ├── Salmo 85_instrumental.opus
│       ├── Salmo 86_instrumental.opus
│       ├── Salmo 87_instrumental.opus
│       ├── Salmo 88_instrumental.opus
│       ├── Salmo 89_instrumental.opus
│       ├── Salmo 8_instrumental.opus
│       ├── Salmo 90_instrumental.opus
│       ├── Salmo 91_instrumental.opus
│       ├── Salmo 92_instrumental.opus
│       ├── Salmo 93_instrumental.opus
│       ├── Salmo 94_instrumental.opus
│       ├── Salmo 95_instrumental.opus
│       ├── Salmo 96_instrumental.opus
│       ├── Salmo 97_instrumental.opus
│       ├── Salmo 98_instrumental.opus
│       ├── Salmo 99_instrumental.opus
│       └── Salmo 9_instrumental.opus
└── src
    ├── app.rs
    ├── bin
    │   └── inspector.rs
    ├── db.rs
    ├── handler.rs
    ├── main.rs
    ├── models.rs
    ├── theme.rs
    └── ui.rs

5 directories, 193 files

Conteúdo dos arquivos Rust:

Arquivo: ./src/app.rs
use crate::{db, models::*, theme::Theme};
use ratatui::widgets::TableState;
use std::path::Path;
use std::process::{Child, Command};

#[derive(Clone, Copy, Debug)]
pub enum MessageType {
    Info,
    Success,
    Error,
}
pub enum InputMode {
    Normal,
    Editing,
}
pub enum CurrentScreen {
    SalterioList,
    SalmoView,
    PiedadeMenu,
    EstudoMenu,
    DiarioList,
    DiarioNew,
    DiarioView,
    AcoesList,
    ResolucoesList,
    SymbolsMenu,
    CfwList,
    CfwSections,
    CmwList,
    CmwAnswer,
    BcwList,
    BcwAnswer,
    Biblia,
}

pub struct App {
    pub should_quit: bool,
    pub current_screen: CurrentScreen,
    pub input: String,
    pub input_mode: InputMode,
    pub status_message: (String, MessageType),
    pub theme: Theme,
    pub salmos: Vec<Salmo>,
    pub salmos_state: TableState,
    pub salmo_scroll: u16,
    pub acoes: Vec<Acao>,
    pub acoes_list_state: TableState,
    pub resolucoes: Vec<Resolucao>,
    pub resolucoes_list_state: TableState,
    pub cfw_capitulos: Vec<CfwCapitulo>,
    pub cfw_list_state: TableState,
    pub cfw_secoes: Vec<CfwSecao>,
    pub cfw_capitulo_titulo: String,
    pub cfw_scroll: u16,
    pub cmw_perguntas: Vec<CatecismoPergunta>,
    pub cmw_list_state: TableState,
    pub cmw_scroll: u16,
    pub bcw_perguntas: Vec<CatecismoPergunta>,
    pub bcw_list_state: TableState,
    pub bcw_scroll: u16,
    pub biblia_versiculos: Vec<Versiculo>,
    pub biblia_referencia: String,
    pub biblia_scroll: u16,
    pub diario_entradas: Vec<EntradaDiario>,
    pub diario_list_state: TableState,
    pub diario_scroll: u16,
    pub audio_process: Option<Child>,
}

impl App {
    pub fn new(
        s: Vec<Salmo>,
        cfw: Vec<CfwCapitulo>,
        cmw: Vec<CatecismoPergunta>,
        bcw: Vec<CatecismoPergunta>,
        diario: Vec<EntradaDiario>,
        acoes: Vec<Acao>,
        resolucoes: Vec<Resolucao>,
    ) -> Self {
        Self {
            should_quit: false,
            current_screen: CurrentScreen::SalterioList,
            input: String::new(),
            input_mode: InputMode::Normal,
            status_message: ("Bem-vindo!".to_string(), MessageType::Info),
            theme: Theme::new(),
            salmos: s,
            salmos_state: TableState::default().with_selected(0),
            salmo_scroll: 0,
            acoes,
            acoes_list_state: TableState::default().with_selected(0),
            resolucoes,
            resolucoes_list_state: TableState::default().with_selected(0),
            cfw_capitulos: cfw,
            cfw_list_state: TableState::default().with_selected(0),
            cfw_secoes: Vec::new(),
            cfw_capitulo_titulo: String::new(),
            cfw_scroll: 0,
            cmw_perguntas: cmw,
            cmw_list_state: TableState::default().with_selected(0),
            cmw_scroll: 0,
            bcw_perguntas: bcw,
            bcw_list_state: TableState::default().with_selected(0),
            bcw_scroll: 0,
            biblia_versiculos: Vec::new(),
            biblia_referencia: "Nenhuma passagem".to_string(),
            biblia_scroll: 0,
            diario_entradas: diario,
            diario_list_state: TableState::default().with_selected(0),
            diario_scroll: 0,
            audio_process: None,
        }
    }
    pub fn refresh_diario(&mut self) {
        if let Ok(e) = db::listar_entradas_diario() {
            self.diario_entradas = e;
            self.diario_list_state.select(Some(0));
        }
    }
    pub fn refresh_acoes(&mut self) {
        if let Ok(a) = db::listar_acoes() {
            self.acoes = a;
            self.acoes_list_state.select(Some(0));
        }
    }
    pub fn refresh_resolucoes(&mut self) {
        if let Ok(r) = db::listar_resolucoes() {
            self.resolucoes = r;
            self.resolucoes_list_state.select(Some(0));
        }
    }
    pub fn enter_salmo_view(&mut self) {
        self.salmo_scroll = 0;
        self.current_screen = CurrentScreen::SalmoView;
    }
    pub fn enter_diario_view(&mut self) {
        self.diario_scroll = 0;
        self.current_screen = CurrentScreen::DiarioView;
    }
    pub fn selected_diario_entry(&self) -> Option<&EntradaDiario> {
        self.diario_entradas
            .get(self.diario_list_state.selected().unwrap_or(0))
    }
    pub fn enter_cfw_chapter_view(&mut self) {
        if let Some(i) = self.cfw_list_state.selected() {
            if let Some(c) = self.cfw_capitulos.get(i) {
                if let Ok(s) = db::ler_secoes_cfw(c.chapter) {
                    self.cfw_secoes = s;
                    self.cfw_capitulo_titulo = c.title.clone();
                    self.cfw_scroll = 0;
                    self.current_screen = CurrentScreen::CfwSections;
                }
            }
        }
    }
    pub fn enter_cmw_answer_view(&mut self) {
        self.cmw_scroll = 0;
        self.current_screen = CurrentScreen::CmwAnswer;
    }
    pub fn enter_bcw_answer_view(&mut self) {
        self.bcw_scroll = 0;
        self.current_screen = CurrentScreen::BcwAnswer;
    }
    pub fn selected_salmo(&self) -> Option<&Salmo> {
        self.salmos.get(self.salmos_state.selected().unwrap_or(0))
    }
    pub fn selected_cmw_question(&self) -> Option<&CatecismoPergunta> {
        self.cmw_perguntas
            .get(self.cmw_list_state.selected().unwrap_or(0))
    }
    pub fn selected_bcw_question(&self) -> Option<&CatecismoPergunta> {
        self.bcw_perguntas
            .get(self.bcw_list_state.selected().unwrap_or(0))
    }
    pub fn stop_audio(&mut self) {
        if let Some(mut child) = self.audio_process.take() {
            if child.kill().is_ok() {
                let _ = child.wait();
                self.status_message = ("Áudio parado.".to_string(), MessageType::Info);
            }
        }
    }
    pub fn play_audio(&mut self, audio_type: &str) {
        self.stop_audio();
        let filename = self.selected_salmo().and_then(|s| {
            match audio_type {
                "instrumental" => s.instrumental.as_ref(),
                "a_capela" => s.a_capela.as_ref(),
                _ => None,
            }
            .cloned()
        });
        if let Some(name) = filename {
            let path = Path::new("./data/saltério").join(&name);
            if path.exists() {
                if let Ok(child) = Command::new("mpv")
                    .args(["--no-video", "--really-quiet", path.to_str().unwrap()])
                    .spawn()
                {
                    self.audio_process = Some(child);
                    self.status_message = (format!("Tocando: {}", name), MessageType::Info);
                } else {
                    self.status_message = (
                        "Erro: 'mpv' não encontrado.".to_string(),
                        MessageType::Error,
                    );
                }
            } else {
                self.status_message = (
                    "Erro: Arquivo não encontrado.".to_string(),
                    MessageType::Error,
                );
            }
        } else {
            self.status_message = (
                format!("Áudio '{}' indisponível.", audio_type),
                MessageType::Info,
            );
        }
    }
    pub fn check_audio_process(&mut self) {
        if let Some(child) = self.audio_process.as_mut() {
            if let Ok(Some(_)) = child.try_wait() {
                self.audio_process.take();
                self.status_message = ("Reprodução terminada.".to_string(), MessageType::Info);
            }
        }
    }
    pub fn submit_command(&mut self) {
        let command_text = self.input.trim();
        if command_text.is_empty() {
            self.input_mode = InputMode::Normal;
            self.input.clear();
            return;
        }
        match self.current_screen {
            CurrentScreen::Biblia => {
                let p: Vec<_> = command_text.split_whitespace().collect();
                if p.get(0) == Some(&"ler") && p.len() == 3 {
                    let b = p[1];
                    if let Ok(c) = p[2].parse::<i32>() {
                        match db::ler_capitulo_biblia(b, c) {
                            Ok(v) if !v.is_empty() => {
                                self.biblia_versiculos = v;
                                self.biblia_referencia = format!("{} {}", b, c).to_uppercase();
                                self.status_message = (
                                    format!("Carregado: {}.", self.biblia_referencia),
                                    MessageType::Success,
                                );
                                self.biblia_scroll = 0;
                            }
                            Ok(_) => {
                                self.status_message = (
                                    format!("Nenhum resultado para '{} {}'.", b, c),
                                    MessageType::Info,
                                );
                            }
                            Err(_) => {
                                self.status_message = (
                                    format!("Erro: Livro '{}' não encontrado.", b),
                                    MessageType::Error,
                                );
                            }
                        }
                    } else {
                        self.status_message =
                            ("Erro: Capítulo inválido.".to_string(), MessageType::Error);
                    }
                } else {
                    self.status_message = ("Comando inválido.".to_string(), MessageType::Error);
                }
            }
            CurrentScreen::AcoesList => {
                if db::criar_acao(command_text).is_ok() {
                    self.refresh_acoes();
                    self.status_message = ("Ação criada.".to_string(), MessageType::Success);
                } else {
                    self.status_message = ("Erro ao criar ação.".to_string(), MessageType::Error);
                }
            }
            CurrentScreen::ResolucoesList => {
                if db::criar_resolucao(command_text).is_ok() {
                    self.refresh_resolucoes();
                    self.status_message = ("Resolução criada.".to_string(), MessageType::Success);
                } else {
                    self.status_message =
                        ("Erro ao criar resolução.".to_string(), MessageType::Error);
                }
            }
            _ => {}
        }
        self.input.clear();
        self.input_mode = InputMode::Normal;
    }
    pub fn quit(&mut self) {
        self.should_quit = true;
    }
    pub fn next(&mut self) {
        match self.current_screen {
            CurrentScreen::SalmoView => {
                self.salmo_scroll = self.salmo_scroll.saturating_add(1);
            }
            CurrentScreen::SalterioList => {
                let i = self.salmos_state.selected().unwrap_or(0);
                self.salmos_state
                    .select(Some(if i >= self.salmos.len() - 1 { 0 } else { i + 1 }));
            }
            CurrentScreen::AcoesList => {
                let i = self.acoes_list_state.selected().unwrap_or(0);
                self.acoes_list_state
                    .select(Some(if i >= self.acoes.len() - 1 { 0 } else { i + 1 }));
            }
            CurrentScreen::ResolucoesList => {
                let i = self.resolucoes_list_state.selected().unwrap_or(0);
                self.resolucoes_list_state
                    .select(Some(if i >= self.resolucoes.len() - 1 {
                        0
                    } else {
                        i + 1
                    }));
            }
            CurrentScreen::DiarioList => {
                let i = self.diario_list_state.selected().unwrap_or(0);
                self.diario_list_state
                    .select(Some(if i >= self.diario_entradas.len() - 1 {
                        0
                    } else {
                        i + 1
                    }));
            }
            CurrentScreen::CfwList => {
                let i = self.cfw_list_state.selected().unwrap_or(0);
                self.cfw_list_state
                    .select(Some(if i >= self.cfw_capitulos.len() - 1 {
                        0
                    } else {
                        i + 1
                    }));
            }
            CurrentScreen::CmwList => {
                let i = self.cmw_list_state.selected().unwrap_or(0);
                self.cmw_list_state
                    .select(Some(if i >= self.cmw_perguntas.len() - 1 {
                        0
                    } else {
                        i + 1
                    }));
            }
            CurrentScreen::BcwList => {
                let i = self.bcw_list_state.selected().unwrap_or(0);
                self.bcw_list_state
                    .select(Some(if i >= self.bcw_perguntas.len() - 1 {
                        0
                    } else {
                        i + 1
                    }));
            }
            CurrentScreen::Biblia => {
                self.biblia_scroll = self.biblia_scroll.saturating_add(1);
            }
            CurrentScreen::DiarioView => {
                self.diario_scroll = self.diario_scroll.saturating_add(1);
            }
            CurrentScreen::CfwSections => {
                self.cfw_scroll = self.cfw_scroll.saturating_add(1);
            }
            CurrentScreen::CmwAnswer => {
                self.cmw_scroll = self.cmw_scroll.saturating_add(1);
            }
            CurrentScreen::BcwAnswer => {
                self.bcw_scroll = self.bcw_scroll.saturating_add(1);
            }
            _ => {}
        }
    }
    pub fn previous(&mut self) {
        match self.current_screen {
            CurrentScreen::SalmoView => {
                self.salmo_scroll = self.salmo_scroll.saturating_sub(1);
            }
            CurrentScreen::SalterioList => {
                let i = self.salmos_state.selected().unwrap_or(0);
                self.salmos_state
                    .select(Some(if i == 0 { self.salmos.len() - 1 } else { i - 1 }));
            }
            CurrentScreen::AcoesList => {
                let i = self.acoes_list_state.selected().unwrap_or(0);
                self.acoes_list_state.select(Some(if i == 0 {
                    self.acoes.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::ResolucoesList => {
                let i = self.resolucoes_list_state.selected().unwrap_or(0);
                self.resolucoes_list_state.select(Some(if i == 0 {
                    self.resolucoes.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::DiarioList => {
                let i = self.diario_list_state.selected().unwrap_or(0);
                self.diario_list_state.select(Some(if i == 0 {
                    self.diario_entradas.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::CfwList => {
                let i = self.cfw_list_state.selected().unwrap_or(0);
                self.cfw_list_state.select(Some(if i == 0 {
                    self.cfw_capitulos.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::CmwList => {
                let i = self.cmw_list_state.selected().unwrap_or(0);
                self.cmw_list_state.select(Some(if i == 0 {
                    self.cmw_perguntas.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::BcwList => {
                let i = self.bcw_list_state.selected().unwrap_or(0);
                self.bcw_list_state.select(Some(if i == 0 {
                    self.bcw_perguntas.len() - 1
                } else {
                    i - 1
                }));
            }
            CurrentScreen::Biblia => {
                self.biblia_scroll = self.biblia_scroll.saturating_sub(1);
            }
            CurrentScreen::DiarioView => {
                self.diario_scroll = self.diario_scroll.saturating_sub(1);
            }
            CurrentScreen::CfwSections => {
                self.cfw_scroll = self.cfw_scroll.saturating_sub(1);
            }
            CurrentScreen::CmwAnswer => {
                self.cmw_scroll = self.cmw_scroll.saturating_sub(1);
            }
            CurrentScreen::BcwAnswer => {
                self.bcw_scroll = self.bcw_scroll.saturating_sub(1);
            }
            _ => {}
        }
    }
}
--- Fim do arquivo ./src/app.rs ---

Arquivo: ./src/ui.rs
use crate::app::{App, CurrentScreen, InputMode, MessageType};
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Style, Stylize},
    text::{Line, Span},
    widgets::{Block, Borders, HighlightSpacing, Paragraph, Row, Table, Wrap},
    Frame,
};

pub fn render(app: &mut App, frame: &mut Frame) {
    frame.render_widget(Block::default().style(app.theme.base_style), frame.size());
    let main_layout = Layout::new(
        Direction::Vertical,
        [Constraint::Min(0), Constraint::Length(3)],
    )
    .split(frame.size());
    let top_layout = Layout::new(
        Direction::Horizontal,
        [Constraint::Percentage(30), Constraint::Percentage(70)],
    )
    .split(main_layout[0]);

    render_main_menu(app, frame, top_layout[0]);

    match app.current_screen {
        CurrentScreen::SalterioList => {
            render_salmos_table(app, frame, top_layout[1]);
            render_salmos_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::SalmoView => {
            render_salmo_view(app, frame, top_layout[1]);
            render_text_view_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::PiedadeMenu => {
            render_piedade_menu(app, frame, top_layout[1]);
            render_menu_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::AcoesList => {
            render_acoes_list(app, frame, top_layout[1]);
            render_acoes_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::ResolucoesList => {
            render_resolucoes_list(app, frame, top_layout[1]);
            render_resolucoes_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::EstudoMenu => {
            render_estudo_menu(app, frame, top_layout[1]);
            render_menu_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::DiarioList => {
            render_diario_list(app, frame, top_layout[1]);
            render_diario_list_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::DiarioView => {
            render_diario_view(app, frame, top_layout[1]);
            render_text_view_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::SymbolsMenu => {
            render_symbols_menu(app, frame, top_layout[1]);
            render_symbols_menu_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::CfwList | CurrentScreen::CmwList | CurrentScreen::BcwList => {
            if let CurrentScreen::CfwList = app.current_screen {
                render_cfw_table(app, frame, top_layout[1]);
            } else if let CurrentScreen::CmwList = app.current_screen {
                render_cmw_table(app, frame, top_layout[1]);
            } else {
                render_bcw_table(app, frame, top_layout[1]);
            }
            render_list_view_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::CfwSections | CurrentScreen::CmwAnswer | CurrentScreen::BcwAnswer => {
            if let CurrentScreen::CfwSections = app.current_screen {
                render_cfw_sections(app, frame, top_layout[1]);
            } else if let CurrentScreen::CmwAnswer = app.current_screen {
                render_cmw_answer(app, frame, top_layout[1]);
            } else {
                render_bcw_answer(app, frame, top_layout[1]);
            }
            render_text_view_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::Biblia => {
            render_biblia_view(app, frame, top_layout[1]);
            render_biblia_footer(app, frame, main_layout[1]);
        }
        CurrentScreen::DiarioNew => {}
    }

    if let InputMode::Editing = app.input_mode {
        frame.set_cursor(
            main_layout[1].x + app.input.len() as u16 + 1,
            main_layout[1].y + 1,
        );
    }
}

fn render_main_menu(app: &App, frame: &mut Frame, area: Rect) {
    let is_canto_active = matches!(
        app.current_screen,
        CurrentScreen::SalterioList | CurrentScreen::SalmoView
    );
    let is_piedade_active = matches!(
        app.current_screen,
        CurrentScreen::PiedadeMenu
            | CurrentScreen::DiarioList
            | CurrentScreen::DiarioView
            | CurrentScreen::DiarioNew
            | CurrentScreen::AcoesList
            | CurrentScreen::ResolucoesList
    );
    let is_estudo_active = matches!(
        app.current_screen,
        CurrentScreen::EstudoMenu
            | CurrentScreen::SymbolsMenu
            | CurrentScreen::CfwList
            | CurrentScreen::CfwSections
            | CurrentScreen::CmwList
            | CurrentScreen::CmwAnswer
            | CurrentScreen::BcwList
            | CurrentScreen::BcwAnswer
            | CurrentScreen::Biblia
    );

    let canto_style = if is_canto_active {
        app.theme.selected_style
    } else {
        app.theme.base_style
    };
    let piedade_style = if is_piedade_active {
        app.theme.selected_style
    } else {
        app.theme.base_style
    };
    let estudo_style = if is_estudo_active {
        app.theme.selected_style
    } else {
        app.theme.base_style
    };

    let audio_indicator = if app.audio_process.is_some() {
        "[♫]"
    } else {
        "   "
    };
    let canto_label = format!("{} [1] Canto  ", audio_indicator);

    let nav_text = vec![
        Line::from("Navegação:"),
        Line::from(""),
        Line::from(Span::styled(canto_label, canto_style)),
        Line::from(Span::styled("   [2] Piedade", piedade_style)),
        Line::from(Span::styled("   [3] Estudo ", estudo_style)),
    ];

    let paragraph = Paragraph::new(nav_text)
        .block(
            Block::default()
                .title("Menu Principal")
                .borders(Borders::ALL),
        )
        .style(app.theme.base_style);
    frame.render_widget(paragraph, area);
}

fn styled_block<'a>(title: &'a str, theme: &crate::theme::Theme) -> Block<'a> {
    Block::default()
        .title(Span::styled(title, Style::default().fg(theme.green).bold()))
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.dim_fg))
}
fn render_piedade_menu(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("\n [1] Diário\n\n [2] Ações de Santificação\n\n [3] Resoluções")
            .block(styled_block("Piedade", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_estudo_menu(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("\n\n   [1] Símbolos de Fé\n\n   [2] Bíblia")
            .block(styled_block("Estudo", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_symbols_menu(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let menu_text = "\n   [1] Confissão de Fé\n\n   [2] Catecismo Maior\n\n   [3] Breve Catecismo";
    frame.render_widget(
        Paragraph::new(menu_text)
            .block(styled_block("Símbolos de Fé", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_acoes_list(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["", "ID", "Descrição"]).style(app.theme.header_style);
    let r = app.acoes.iter().map(|a| {
        let (icon, s) = if a.status == "completo" {
            ("[✓]", Style::default().fg(app.theme.green).dim())
        } else {
            ("[ ]", app.theme.base_style)
        };
        Row::new(vec![
            Span::styled(icon, s),
            Span::raw(a.id.to_string()),
            Span::raw(a.descricao.clone()),
        ])
        .style(s)
    });
    let t = Table::new(
        r,
        &[
            Constraint::Length(3),
            Constraint::Length(4),
            Constraint::Min(20),
        ],
    )
    .header(h)
    .block(styled_block("Ações de Santificação", &app.theme))
    .highlight_style(app.theme.selected_style)
    .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.acoes_list_state);
}
fn render_resolucoes_list(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["ID", "Texto"]).style(app.theme.header_style);
    let r = app
        .resolucoes
        .iter()
        .map(|r| Row::new([r.id.to_string(), r.texto.clone()]));
    let t = Table::new(r, &[Constraint::Length(4), Constraint::Min(20)])
        .header(h)
        .block(styled_block("Minhas Resoluções", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.resolucoes_list_state);
}
fn render_diario_list(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["Data", "Início da Entrada"]).style(app.theme.header_style);
    let r = app.diario_entradas.iter().map(|e| {
        let p = e.texto.chars().take(80).collect::<String>() + "...";
        Row::new([e.data.clone(), p])
    });
    let t = Table::new(r, &[Constraint::Length(20), Constraint::Min(20)])
        .header(h)
        .block(styled_block("Diário", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.diario_list_state);
}
fn render_diario_view(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    if let Some(e) = app.selected_diario_entry() {
        let title = format!("Diário - {}", e.data);
        let p = Paragraph::new(e.texto.as_str())
            .wrap(Wrap { trim: true })
            .scroll((app.diario_scroll, 0))
            .block(styled_block(&title, &app.theme))
            .style(app.theme.base_style);
        frame.render_widget(p, area);
    }
}
fn render_salmo_view(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    if let Some(s) = app.selected_salmo() {
        let txt = s.letra.as_deref().unwrap_or("Letra não disponível.");
        let title = format!("Salmo - {}", s.referencia);
        let p = Paragraph::new(txt)
            .wrap(Wrap { trim: true })
            .scroll((app.salmo_scroll, 0))
            .block(styled_block(&title, &app.theme))
            .style(app.theme.base_style);
        frame.render_widget(p, area);
    }
}
fn render_salmos_table(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["Ref.", "Melodia"]).style(app.theme.header_style);
    let r = app
        .salmos
        .iter()
        .map(|s| Row::new([s.referencia.clone(), s.melodia.clone().unwrap_or_default()]));
    let t = Table::new(r, &[Constraint::Percentage(40), Constraint::Percentage(60)])
        .header(h)
        .block(styled_block("Saltério", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.salmos_state);
}
fn render_cfw_table(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["Cap.", "Título"]).style(app.theme.header_style);
    let r = app
        .cfw_capitulos
        .iter()
        .map(|c| Row::new([c.chapter.to_string(), c.title.clone()]));
    let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
        .header(h)
        .block(styled_block("Confissão de Fé", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.cfw_list_state);
}
fn render_cfw_sections(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let text: String = app
        .cfw_secoes
        .iter()
        .map(|s| format!("{}. {}\n\n", s.section, s.text))
        .collect();
    let title = format!("CFW: {}", app.cfw_capitulo_titulo);
    let p = Paragraph::new(text)
        .wrap(Wrap { trim: false })
        .scroll((app.cfw_scroll, 0))
        .block(styled_block(&title, &app.theme))
        .style(app.theme.base_style);
    frame.render_widget(p, area);
}
fn render_biblia_view(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let txt = if app.biblia_versiculos.is_empty() {
        "\n\n\nUse [e] para buscar.".to_string()
    } else {
        app.biblia_versiculos
            .iter()
            .map(|v| format!("[{}] {}\n", v.verse, v.text))
            .collect()
    };
    let title = format!("Bíblia: {}", app.biblia_referencia);
    let p = Paragraph::new(txt)
        .wrap(Wrap { trim: false })
        .scroll((app.biblia_scroll, 0))
        .block(styled_block(&title, &app.theme))
        .style(app.theme.base_style);
    frame.render_widget(p, area);
}
fn render_cmw_table(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["Per.", "Pergunta"]).style(app.theme.header_style);
    let r = app
        .cmw_perguntas
        .iter()
        .map(|p| Row::new([p.id.to_string(), p.question.clone()]));
    let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
        .header(h)
        .block(styled_block("Catecismo Maior", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.cmw_list_state);
}
fn render_cmw_answer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    if let Some(p) = app.selected_cmw_question() {
        let title = format!("CMW Pergunta {}", p.id);
        let txt = vec![
            Line::from(vec![
                Span::styled("P: ", Style::default().bold().fg(app.theme.yellow)),
                Span::raw(&p.question),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("R: ", Style::default().bold().fg(app.theme.yellow)),
                Span::raw(&p.answer),
            ]),
        ];
        let par = Paragraph::new(txt)
            .wrap(Wrap { trim: true })
            .scroll((app.cmw_scroll, 0))
            .block(styled_block(&title, &app.theme))
            .style(app.theme.base_style);
        frame.render_widget(par, area);
    }
}
fn render_bcw_table(app: &mut App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let h = Row::new(["Per.", "Pergunta"]).style(app.theme.header_style);
    let r = app
        .bcw_perguntas
        .iter()
        .map(|p| Row::new([p.id.to_string(), p.question.clone()]));
    let t = Table::new(r, &[Constraint::Length(5), Constraint::Min(20)])
        .header(h)
        .block(styled_block("Breve Catecismo", &app.theme))
        .highlight_style(app.theme.selected_style)
        .highlight_spacing(HighlightSpacing::Always);
    frame.render_stateful_widget(t, area, &mut app.bcw_list_state);
}
fn render_bcw_answer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    if let Some(p) = app.selected_bcw_question() {
        let title = format!("BCW Pergunta {}", p.id);
        let txt = vec![
            Line::from(vec![
                Span::styled("P: ", Style::default().bold().fg(app.theme.yellow)),
                Span::raw(&p.question),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("R: ", Style::default().bold().fg(app.theme.yellow)),
                Span::raw(&p.answer),
            ]),
        ];
        let par = Paragraph::new(txt)
            .wrap(Wrap { trim: true })
            .scroll((app.cmw_scroll, 0))
            .block(styled_block(&title, &app.theme))
            .style(app.theme.base_style);
        frame.render_widget(par, area);
    }
}
fn render_menu_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("Use os números para selecionar ou [v] para voltar.")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_salmos_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("[Enter] Ver Letra | [t] Tocar | [c] Cantar | [s] Parar")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_acoes_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let text = match app.input_mode {
        InputMode::Normal => "[n] Nova | [c] Completar | [p] Pender | [d] Deletar | [v] Voltar",
        InputMode::Editing => "Nova Ação:",
    };
    frame.render_widget(
        Paragraph::new(text)
            .block(styled_block("Comandos", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_resolucoes_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let text = match app.input_mode {
        InputMode::Normal => "[n] Nova | [d] Deletar | [v] Voltar",
        InputMode::Editing => "Nova Resolução:",
    };
    frame.render_widget(
        Paragraph::new(text)
            .block(styled_block("Comandos", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_diario_list_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("[n] Nova Entrada | [Enter] Ver | [v] Voltar")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_symbols_menu_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("[1], [2], [3] Selecionar | [v] Voltar")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_list_view_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("[Enter] Ver | [v] Voltar")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}
fn render_text_view_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    frame.render_widget(
        Paragraph::new("[j/k] Rolar | [v] Voltar")
            .block(styled_block("Ajuda", &app.theme))
            .style(app.theme.base_style),
        area,
    );
}

fn render_biblia_footer(app: &App, frame: &mut Frame, area: ratatui::layout::Rect) {
    let block_title = if matches!(app.input_mode, InputMode::Editing) {
        "Comando"
    } else {
        "Status"
    };

    let (text, style) = match app.input_mode {
        InputMode::Editing => (app.input.as_str(), app.theme.base_style),
        InputMode::Normal => {
            let (status_text, msg_type) = &app.status_message;
            let fg_color = match msg_type {
                MessageType::Success => app.theme.green,
                MessageType::Error => app.theme.red,
                MessageType::Info => app.theme.fg,
            };
            (status_text.as_str(), app.theme.base_style.fg(fg_color))
        }
    };

    let paragraph = Paragraph::new(text)
        .style(style)
        .block(styled_block(block_title, &app.theme));
    frame.render_widget(paragraph, area);
}
--- Fim do arquivo ./src/ui.rs ---

Arquivo: ./src/models.rs
/// Representa um único registro da tabela 'salterio'.
#[derive(Clone, Debug)]
pub struct Salmo {
    pub id: i32,
    pub referencia: String,
    pub melodia: Option<String>,
    pub tema: Option<String>,
    pub letra: Option<String>, // Campo para a letra completa
    pub instrumental: Option<String>,
    pub a_capela: Option<String>,
}

/// Representa uma ação de santificação.
#[derive(Clone, Debug)]
pub struct Acao {
    pub id: i32,
    pub descricao: String,
    pub status: String,
}

/// Representa uma resolução pessoal.
#[derive(Clone, Debug)]
pub struct Resolucao {
    pub id: i32,
    pub texto: String,
}

/// Representa uma entrada do diário.
#[derive(Clone, Debug)]
pub struct EntradaDiario {
    pub id: i32,
    pub data: String,
    pub texto: String,
}

/// Representa um capítulo da Confissão de Fé de Westminster.
#[derive(Clone, Debug)]
pub struct CfwCapitulo {
    pub chapter: i32,
    pub title: String,
}

/// Representa uma seção de um capítulo da CFW.
#[derive(Clone, Debug)]
pub struct CfwSecao {
    pub section: i32,
    pub text: String,
}

/// Representa uma pergunta e resposta de um catecismo.
#[derive(Clone, Debug)]
pub struct CatecismoPergunta {
    pub id: i32,
    pub question: String,
    pub answer: String,
}

/// Representa um único versículo da Bíblia.
#[derive(Clone, Debug)]
pub struct Versiculo {
    pub verse: i32,
    pub text: String,
}
--- Fim do arquivo ./src/models.rs ---

Arquivo: ./src/handler.rs
use crate::app::{App, CurrentScreen, InputMode};
use crate::db;
use crossterm::event::{KeyCode, KeyEvent, KeyEventKind};

fn handle_normal_mode(key: KeyEvent, app: &mut App) {
    if let KeyCode::Char('q') = key.code {
        app.quit();
        return;
    }

    match app.current_screen {
        CurrentScreen::SalterioList => match key.code {
            KeyCode::Char('2') => app.current_screen = CurrentScreen::PiedadeMenu,
            KeyCode::Char('3') => app.current_screen = CurrentScreen::EstudoMenu,
            KeyCode::Enter => app.enter_salmo_view(),
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('t') => app.play_audio("instrumental"),
            KeyCode::Char('c') => app.play_audio("a_capela"),
            KeyCode::Char('s') => app.stop_audio(),
            _ => {}
        },
        CurrentScreen::SalmoView => match key.code {
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::SalterioList,
            _ => {}
        },
        CurrentScreen::PiedadeMenu => match key.code {
            KeyCode::Char('1') => app.current_screen = CurrentScreen::DiarioList,
            KeyCode::Char('2') => app.current_screen = CurrentScreen::AcoesList,
            KeyCode::Char('3') => app.current_screen = CurrentScreen::ResolucoesList,
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::SalterioList,
            _ => {}
        },
        // ... outras telas ...
        CurrentScreen::AcoesList => match key.code {
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::PiedadeMenu,
            KeyCode::Char('n') => app.input_mode = InputMode::Editing,
            KeyCode::Char('d') | KeyCode::Char('c') | KeyCode::Char('p') => {
                if let Some(index) = app.acoes_list_state.selected() {
                    if let Some(acao) = app.acoes.get(index) {
                        let id = acao.id;
                        let success = match key.code {
                            KeyCode::Char('d') => db::deletar_acao(id).is_ok(),
                            KeyCode::Char('c') => db::atualizar_status_acao(id, "completo").is_ok(),
                            KeyCode::Char('p') => db::atualizar_status_acao(id, "pendente").is_ok(),
                            _ => false,
                        };
                        if success {
                            app.refresh_acoes();
                        }
                    }
                }
            }
            _ => {}
        },
        CurrentScreen::ResolucoesList => match key.code {
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::PiedadeMenu,
            KeyCode::Char('n') => app.input_mode = InputMode::Editing,
            KeyCode::Char('d') => {
                if let Some(index) = app.resolucoes_list_state.selected() {
                    if let Some(res) = app.resolucoes.get(index) {
                        if db::deletar_resolucao(res.id).is_ok() {
                            app.refresh_resolucoes();
                        }
                    }
                }
            }
            _ => {}
        },
        CurrentScreen::EstudoMenu => match key.code {
            KeyCode::Char('1') => app.current_screen = CurrentScreen::SymbolsMenu,
            KeyCode::Char('2') => app.current_screen = CurrentScreen::Biblia,
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::SalterioList,
            _ => {}
        },
        CurrentScreen::SymbolsMenu => match key.code {
            KeyCode::Char('1') => app.current_screen = CurrentScreen::CfwList,
            KeyCode::Char('2') => app.current_screen = CurrentScreen::CmwList,
            KeyCode::Char('3') => app.current_screen = CurrentScreen::BcwList,
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::EstudoMenu,
            _ => {}
        },
        CurrentScreen::DiarioList => match key.code {
            KeyCode::Char('n') => app.current_screen = CurrentScreen::DiarioNew,
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Enter => app.enter_diario_view(),
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::PiedadeMenu,
            _ => {}
        },
        CurrentScreen::CfwList | CurrentScreen::CmwList | CurrentScreen::BcwList => {
            match key.code {
                KeyCode::Char('j') | KeyCode::Down => app.next(),
                KeyCode::Char('k') | KeyCode::Up => app.previous(),
                KeyCode::Enter => match app.current_screen {
                    CurrentScreen::CfwList => app.enter_cfw_chapter_view(),
                    CurrentScreen::CmwList => app.enter_cmw_answer_view(),
                    CurrentScreen::BcwList => app.enter_bcw_answer_view(),
                    _ => {}
                },
                KeyCode::Char('v') | KeyCode::Esc => {
                    app.current_screen = CurrentScreen::SymbolsMenu
                }
                _ => {}
            }
        }
        CurrentScreen::DiarioView
        | CurrentScreen::CfwSections
        | CurrentScreen::CmwAnswer
        | CurrentScreen::BcwAnswer => match key.code {
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('v') | KeyCode::Esc => match app.current_screen {
                CurrentScreen::DiarioView => app.current_screen = CurrentScreen::DiarioList,
                CurrentScreen::CfwSections => app.current_screen = CurrentScreen::CfwList,
                CurrentScreen::CmwAnswer => app.current_screen = CurrentScreen::CmwList,
                CurrentScreen::BcwAnswer => app.current_screen = CurrentScreen::BcwList,
                _ => {}
            },
            _ => {}
        },
        CurrentScreen::Biblia => match key.code {
            KeyCode::Char('j') | KeyCode::Down => app.next(),
            KeyCode::Char('k') | KeyCode::Up => app.previous(),
            KeyCode::Char('e') => app.input_mode = InputMode::Editing,
            KeyCode::Char('v') | KeyCode::Esc => app.current_screen = CurrentScreen::EstudoMenu,
            _ => {}
        },
        _ => {}
    }
}
pub fn handle_key_events(key: KeyEvent, app: &mut App) {
    if key.kind != KeyEventKind::Press {
        return;
    }
    match app.input_mode {
        InputMode::Normal => handle_normal_mode(key, app),
        InputMode::Editing => match key.code {
            KeyCode::Enter => app.submit_command(),
            KeyCode::Char(c) => app.input.push(c),
            KeyCode::Backspace => {
                app.input.pop();
            }
            KeyCode::Esc => {
                app.input.clear();
                app.input_mode = InputMode::Normal;
            }
            _ => {}
        },
    }
}
--- Fim do arquivo ./src/handler.rs ---

Arquivo: ./src/bin/inspector.rs
use rusqlite::{Connection, Result};

const DB_PATH: &str = "./data/dados.db";

fn main() -> Result<()> {
    let conn = Connection::open(DB_PATH)?;

    // --- 1. Lista os nomes dos livros ---
    println!("--- Livros Disponíveis no Banco de Dados ---");
    let mut stmt_books = conn.prepare("SELECT name FROM book ORDER BY id")?;
    let book_iter = stmt_books.query_map([], |row| row.get::<_, String>(0))?;

    for book in book_iter {
        println!("{}", book?);
    }

    // --- 2. Lista as versões da Bíblia ---
    println!("\n--- Versões da Bíblia Disponíveis ---");
    let mut stmt_versions = conn.prepare("SELECT DISTINCT version FROM verse")?;
    let version_iter = stmt_versions.query_map([], |row| row.get::<_, String>(0))?;

    for version in version_iter {
        println!("{}", version?);
    }

    Ok(())
}
--- Fim do arquivo ./src/bin/inspector.rs ---

Arquivo: ./src/theme.rs
use ratatui::style::{Color, Style, Stylize};

pub struct Theme {
    pub bg: Color,
    pub fg: Color,
    pub highlight_bg: Color,
    pub yellow: Color,
    pub green: Color,
    pub blue: Color,
    pub red: Color,
    pub dim_fg: Color,

    pub base_style: Style,
    pub header_style: Style,
    pub selected_style: Style,
}

impl Theme {
    pub fn new() -> Self {
        let bg = Color::Rgb(40, 40, 40);
        let fg = Color::Rgb(235, 219, 178);
        let highlight_bg = Color::Rgb(60, 56, 54);
        let yellow = Color::Rgb(250, 189, 47);
        let green = Color::Rgb(184, 187, 38);
        let blue = Color::Rgb(131, 165, 152);
        let red = Color::Rgb(251, 73, 52);
        let dim_fg = Color::Rgb(146, 131, 116);

        Self {
            bg,
            fg,
            highlight_bg,
            yellow,
            green,
            blue,
            red,
            dim_fg,
            base_style: Style::default().bg(bg).fg(fg),
            header_style: Style::default().fg(blue).bold(),
            selected_style: Style::default().bg(highlight_bg).fg(fg),
        }
    }
}
--- Fim do arquivo ./src/theme.rs ---

Arquivo: ./src/main.rs
mod app;
mod db;
mod handler;
mod models;
mod theme;
mod ui;
use crate::app::{App, CurrentScreen, MessageType};
use crossterm::{
    event::{self, Event},
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    ExecutableCommand,
};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::fs;
use std::io::{self, stdout, Read, Stdout};
use std::process::Command;
use std::time::Duration;
use tempfile::NamedTempFile;

fn main() -> io::Result<()> {
    let salmos = db::listar_salmos().expect("Falha ao carregar salmos.");
    let cfw = db::listar_capitulos_cfw().expect("Falha ao carregar CFW.");
    let cmw = db::listar_perguntas_cmw().expect("Falha ao carregar CMW.");
    let bcw = db::listar_perguntas_bcw().expect("Falha ao carregar BCW.");
    let diario = db::listar_entradas_diario().expect("Falha ao carregar Diário.");
    let acoes = db::listar_acoes().expect("Falha ao carregar Ações.");
    let resolucoes = db::listar_resolucoes().expect("Falha ao carregar Resoluções.");

    let mut terminal = setup_terminal()?;
    let mut app = App::new(salmos, cfw, cmw, bcw, diario, acoes, resolucoes);

    run(&mut terminal, &mut app)?;

    app.stop_audio();
    restore_terminal()?;
    Ok(())
}

fn run(terminal: &mut Terminal<CrosstermBackend<Stdout>>, app: &mut App) -> io::Result<()> {
    while !app.should_quit {
        if let CurrentScreen::DiarioNew = app.current_screen {
            restore_terminal()?;
            app.status_message = match launch_editor_and_save_entry() {
                Ok(msg_tuple) => {
                    app.refresh_diario();
                    msg_tuple
                }
                Err(e) => (format!("Erro: {}", e), MessageType::Error),
            };
            setup_terminal()?;
            app.current_screen = CurrentScreen::DiarioList;
        }
        let _ = terminal.draw(|frame| ui::render(app, frame));
        app.check_audio_process();
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                handler::handle_key_events(key, app);
            }
        }
    }
    Ok(())
}

fn launch_editor_and_save_entry() -> io::Result<(String, MessageType)> {
    let editor = std::env::var("EDITOR").unwrap_or_else(|_| "nano".to_string());
    let temp_file = NamedTempFile::new()?;
    let temp_path = temp_file.path();
    let status = Command::new(&editor).arg(temp_path).status()?;

    if !status.success() {
        return Ok(("Criação cancelada.".to_string(), MessageType::Info));
    }
    let mut contents = String::new();
    fs::File::open(temp_path)?.read_to_string(&mut contents)?;
    if contents.trim().is_empty() {
        return Ok(("Criação cancelada (vazio).".to_string(), MessageType::Info));
    }

    match db::criar_entrada_diario(&contents) {
        Ok(_) => Ok(("Nova entrada salva!".to_string(), MessageType::Success)),
        Err(_) => Ok(("Erro ao salvar no banco.".to_string(), MessageType::Error)),
    }
}

fn setup_terminal() -> io::Result<Terminal<CrosstermBackend<Stdout>>> {
    enable_raw_mode()?;
    stdout().execute(EnterAlternateScreen)?;
    Terminal::new(CrosstermBackend::new(stdout()))
}
fn restore_terminal() -> io::Result<()> {
    disable_raw_mode()?;
    stdout().execute(LeaveAlternateScreen)?;
    Ok(())
}
--- Fim do arquivo ./src/main.rs ---

Arquivo: ./src/db.rs
use crate::models::{
    Acao, CatecismoPergunta, CfwCapitulo, CfwSecao, EntradaDiario, Resolucao, Salmo, Versiculo,
};
use chrono::Local;
use rusqlite::{Connection, Result};
const DB_PATH: &str = "./data/dados.db";

pub fn listar_salmos() -> Result<Vec<Salmo>> {
    let conn = Connection::open(DB_PATH)?;
    // CORREÇÃO: Adiciona a coluna `letra` à consulta SQL.
    let mut stmt = conn.prepare("SELECT id, referencia, melodia, tema, letra, instrumental, \"à_capela\" FROM salterio ORDER BY CAST(referencia AS INTEGER)")?;
    let salmos_iter = stmt.query_map([], |row| {
        Ok(Salmo {
            id: row.get(0)?,
            referencia: row.get(1)?,
            melodia: row.get(2)?,
            tema: row.get(3)?,
            letra: row.get(4)?,
            instrumental: row.get(5)?,
            a_capela: row.get(6)?,
        })
    })?;
    Ok(salmos_iter.collect::<Result<Vec<Salmo>>>()?)
}
// ... resto do arquivo db.rs sem alterações ...
pub fn listar_capitulos_cfw() -> Result<Vec<CfwCapitulo>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt = conn.prepare("SELECT DISTINCT chapter, title FROM cfw ORDER BY chapter")?;
    let cap_iter = stmt.query_map([], |row| {
        Ok(CfwCapitulo {
            chapter: row.get(0)?,
            title: row.get(1)?,
        })
    })?;
    Ok(cap_iter.collect::<Result<Vec<CfwCapitulo>>>()?)
}
pub fn ler_capitulo_biblia(nome_livro: &str, capitulo: i32) -> Result<Vec<Versiculo>> {
    let conn = Connection::open(DB_PATH)?;
    let book_id: i32 = conn.query_row(
        "SELECT id FROM book WHERE lower(name) = lower(?1)",
        [nome_livro],
        |row| row.get(0),
    )?;
    let mut stmt = conn.prepare("SELECT verse, text FROM verse WHERE book_id = ?1 AND chapter = ?2 AND version = 'ARA' ORDER BY verse")?;
    let verse_iter = stmt.query_map([book_id, capitulo], |row| {
        Ok(Versiculo {
            verse: row.get(0)?,
            text: row.get(1)?,
        })
    })?;
    Ok(verse_iter.collect::<Result<Vec<Versiculo>>>()?)
}
pub fn ler_secoes_cfw(numero_capitulo: i32) -> Result<Vec<CfwSecao>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt =
        conn.prepare("SELECT section, text FROM cfw WHERE chapter = ? ORDER BY section")?;
    let secoes_iter = stmt.query_map([numero_capitulo], |row| {
        Ok(CfwSecao {
            section: row.get(0)?,
            text: row.get(1)?,
        })
    })?;
    Ok(secoes_iter.collect::<Result<Vec<CfwSecao>>>()?)
}
pub fn listar_perguntas_cmw() -> Result<Vec<CatecismoPergunta>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, question, answer FROM cmw ORDER BY id")?;
    let iter = stmt.query_map([], |row| {
        Ok(CatecismoPergunta {
            id: row.get(0)?,
            question: row.get(1)?,
            answer: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<CatecismoPergunta>>>()?)
}
pub fn listar_perguntas_bcw() -> Result<Vec<CatecismoPergunta>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, question, answer FROM bcw ORDER BY id")?;
    let iter = stmt.query_map([], |row| {
        Ok(CatecismoPergunta {
            id: row.get(0)?,
            question: row.get(1)?,
            answer: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<CatecismoPergunta>>>()?)
}
pub fn listar_entradas_diario() -> Result<Vec<EntradaDiario>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, data, texto FROM diario ORDER BY data DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(EntradaDiario {
            id: row.get(0)?,
            data: row.get(1)?,
            texto: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<EntradaDiario>>>()?)
}
pub fn criar_entrada_diario(texto: &str) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO diario (data, texto) VALUES (?1, ?2)",
        (data_atual, texto),
    )?;
    Ok(())
}
pub fn listar_acoes() -> Result<Vec<Acao>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt =
        conn.prepare("SELECT id, descricao, status FROM acoes ORDER BY status, id DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(Acao {
            id: row.get(0)?,
            descricao: row.get(1)?,
            status: row.get(2)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<Acao>>>()?)
}
pub fn criar_acao(descricao: &str) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO acoes (descricao, data_criacao) VALUES (?1, ?2)",
        (descricao, data_atual),
    )?;
    Ok(())
}
pub fn atualizar_status_acao(id: i32, status: &str) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    conn.execute("UPDATE acoes SET status = ?1 WHERE id = ?2", (status, id))?;
    Ok(())
}
pub fn deletar_acao(id: i32) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    conn.execute("DELETE FROM acoes WHERE id = ?1", [id])?;
    Ok(())
}
pub fn listar_resolucoes() -> Result<Vec<Resolucao>> {
    let conn = Connection::open(DB_PATH)?;
    let mut stmt = conn.prepare("SELECT id, texto FROM resolucoes ORDER BY id DESC")?;
    let iter = stmt.query_map([], |row| {
        Ok(Resolucao {
            id: row.get(0)?,
            texto: row.get(1)?,
        })
    })?;
    Ok(iter.collect::<Result<Vec<Resolucao>>>()?)
}
pub fn criar_resolucao(texto: &str) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    let data_atual = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    conn.execute(
        "INSERT INTO resolucoes (texto, data_criacao) VALUES (?1, ?2)",
        (texto, data_atual),
    )?;
    Ok(())
}
pub fn deletar_resolucao(id: i32) -> Result<()> {
    let conn = Connection::open(DB_PATH)?;
    conn.execute("DELETE FROM resolucoes WHERE id = ?1", [id])?;
    Ok(())
}
--- Fim do arquivo ./src/db.rs ---

Arquivo: Cargo.toml
[package]
name = "cyber_puritano"
version = "0.1.0"
edition = "2021"
default-run = "cyber_puritano"

[dependencies]
crossterm = "0.27.0"
ratatui = "0.26.1"
rusqlite = { version = "0.31.0", features = ["bundled"] }
tokio = { version = "1.36.0", features = ["full"] }

[[bin]]
name = "inspector"
path = "src/bin/inspector.rs"

[dependencies.chrono]
version = "0.4.38"

[dependencies.tempfile]
version = "3.10.1"
--- Fim do arquivo Cargo.toml ---


Esquema dos arquivos SQLite:

Banco de Dados: ./data/dados.db
CREATE TABLE IF NOT EXISTS "texts" (id INTEGER PRIMARY KEY AUTOINCREMENT, document TEXT NOT NULL, location TEXT NOT NULL);
CREATE TABLE sqlite_sequence(name,seq);
CREATE TABLE IF NOT EXISTS "proof_texts" (id INTEGER PRIMARY KEY AUTOINCREMENT, text_id INTEGER NOT NULL, book_id INTEGER NOT NULL, chapter INTEGER NOT NULL, verse INTEGER NOT NULL, FOREIGN KEY (text_id) REFERENCES "texts" (id));
CREATE TABLE IF NOT EXISTS "cfw" (id INTEGER PRIMARY KEY AUTOINCREMENT, chapter INTEGER NOT NULL, section INTEGER NOT NULL, title TEXT NOT NULL, text TEXT NOT NULL);
CREATE TABLE cmw (id INTEGER PRIMARY KEY, question TEXT NOT NULL, answer TEXT NOT NULL);
CREATE TABLE bcw (id INTEGER PRIMARY KEY, question TEXT NOT NULL, answer TEXT NOT NULL);
CREATE TABLE salterio (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    referencia TEXT NOT NULL UNIQUE,
    metrica TEXT,
    melodia TEXT,
    compositor TEXT,
    harmonizacao TEXT,
    letra TEXT,
    instrumental TEXT,
    "à_capela" TEXT,
    tema TEXT
);
CREATE TABLE testament (
    "id"    INTEGER PRIMARY KEY,
    "name"  TEXT
);
CREATE TABLE book (
    "id"    INTEGER PRIMARY KEY,
    "book_reference_id"     INTEGER,
    "testament_reference_id" INTEGER,
    "name"  TEXT
);
CREATE TABLE verse (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    book_id INTEGER NOT NULL,
    chapter INTEGER NOT NULL,
    verse INTEGER NOT NULL,
    text TEXT,
    version TEXT NOT NULL
);
CREATE INDEX idx_verse_lookup ON verse (version, book_id, chapter);
CREATE VIEW vw_simbolos_com_provas AS
SELECT
  t.document AS simbolo,
  t.location AS localizacao,
  p.book_id,
  p.chapter,
  p.verse
FROM
  texts AS t
JOIN
  proof_texts AS p ON t.id = p.text_id
/* vw_simbolos_com_provas(simbolo,localizacao,book_id,chapter,verse) */;
CREATE TABLE diario (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            data TEXT NOT NULL,
            texto TEXT NOT NULL
        );
CREATE TABLE acoes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            descricao TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'pendente', -- 'pendente' ou 'completo'
            data_criacao TEXT NOT NULL
        );
CREATE TABLE resolucoes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            texto TEXT NOT NULL,
            data_criacao TEXT NOT NULL
        );
CREATE TABLE sermoes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    titulo TEXT NOT NULL,
    tema TEXT,
    pregador TEXT,
    local TEXT,
    data TEXT, -- Formato 'YYYY-MM-DD'
    link TEXT,
    passagem_principal TEXT NOT NULL
);
CREATE TABLE notas_estudo (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    referencia_biblica TEXT NOT NULL, -- Ex: 'Joao 3:16' ou 'Genesis 1'
    texto TEXT NOT NULL,
    data_criacao TEXT NOT NULL
);
